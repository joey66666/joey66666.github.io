<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>Medium | Leetcode-cn 笔记 | 片刻静思</title>
<link rel="stylesheet" href="/css/eureka.min.css">
<script defer src="/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112541018-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-112541018-1');
</script>


<link rel="icon" type="image/png" sizes="32x32" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_2.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_2.png">

<meta name="description"
  content="[2] 两数相加 [3] 无重复字符的最长子串 [8] 字符串转换整数 (atoi) [11] 盛最多水的容器 [15] 三数之和 [16] 最接近的三数之和 [19] 删除链表的倒数第N个节点 [24] 两两交换链表中的节点 [31] 下一个排列 [33] 搜索旋转排序数组 [36] 有效的数独 [46] 全排列 [48] 旋转图像 [49] Group Anagrams，字母异位词分组 [55] 跳跃游戏 [61] 旋转链表 [62] 不同路径 [64] 最小路径和 [74] 搜索二维矩阵 [75] 颜色分类 [78] 子集 [80] 删除有序数组中的重复项 II [81] 搜索旋转排序数组 II [82] 删除排序链表中的重复元素 II [86] 分隔链表 [91] 解码方法 [92] Reverse Linked List II [93] 复原IP地址 [94] 二叉树的中序遍历 [98] 验证二叉搜索树 [103] 二叉树的锯齿形层次遍历 [116] 填充每个节点的下一个右侧节点指针 [117] 填充每个节点的下一个右侧节点指针 II [124] 二叉树中的最大路径和 [127] 单词接龙 [134] 加油站 [137] 只出现一次的数字 II [142] 环形链表 II [144] 二叉树的前序遍历 [146] LRU缓存机制 [179] Largest Number 最大数 [200] 岛屿数量 [201] 数字范围按位与 [207] 课程表 [208] 实现 Trie (前缀树) [213] 打家劫舍 II [215] 数组中的第K个最大元素 [220] 存在重复元素 III [221] 最大正方形 [238] 除自身以外数组的乘积 [316] 去除重复字母 [324] 摆动排序 II [338] 比特位计数 [341] 扁平化嵌套列表迭代器 [376] 摆动序列 [377] 组合总和 Ⅳ [402] 移掉K位数字 [424] 替换后的最长重复字符 [421] 数组中两个数的最大异或值 [495] Teemo Attacking [503] 下一个更大元素 II [525] 连续数组 [540] 有序数组中的单一元素 [554] 砖墙 [560] 和为K的子数组 [633] 平方数之和 [649] Dota2 参议院 [659] 分割数组为连续子序列 [678] 有效的括号字符串 [692] 前K个高频单词 [714] 买卖股票的最佳时机含手续费 [738] 单调递增的数字 [740] 删除与获得点数 [861] 翻转矩阵后的得分 [877] 石子游戏 [901] 股票价格跨度 [907] 子数组的最小值之和 [1004] 最大连续1的个数 III [1008] 先序遍历构造二叉树 [1011] 在 D 天内送达包裹的能力 [1094] Car Pooling [1143] 最长公共子序列 [1208] 尽可能使字符串相等 [1310] 子数组异或查询 [1395] 统计作战单位数 [1442] 形成两个异或相等数组的三元组数目 [1551] 使数组中所有元素相等的最小操作数 [1734] 解码异或后的排列 [1738] 找出第 K 大的异或坐标值 First Unique Numer Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree 合并k个排序数组 面试题 08.">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Leetcode 解题笔记",
      "item":"/zh/docs/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Leetcode-cn 笔记",
      "item":"/zh/docs/notes/"},{
      "@type": "ListItem",
      "position": 3 ,
      "name":"Medium",
      "item":"/zh/docs/notes/medium/"}]
}
</script><script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/zh/docs/notes/medium/"
    },
    "headline": "Medium | Leetcode-cn 笔记 | 片刻静思","datePublished": "2020-12-17T22:15:32+08:00",
    "dateModified": "2021-06-25T17:21:55+08:00",
    "wordCount":  2697 ,
    "publisher": {
        "@type": "Person",
        "name": "z. Joey",
        "logo": {
            "@type": "ImageObject",
            "url": "/images/icon.png"
        }
        },
    "description": "[2] 两数相加 [3] 无重复字符的最长子串 [8] 字符串转换整数 (atoi) [11] 盛最多水的容器 [15] 三数之和 [16] 最接近的三数之和 [19] 删除链表的倒数第N个节点 [24] 两两交换链表中的节点 [31] 下一个排列 [33] 搜索旋转排序数组 [36] 有效的数独 [46] 全排列 [48] 旋转图像 [49] Group Anagrams，字母异位词分组 [55] 跳跃游戏 [61] 旋转链表 [62] 不同路径 [64] 最小路径和 [74] 搜索二维矩阵 [75] 颜色分类 [78] 子集 [80] 删除有序数组中的重复项 II [81] 搜索旋转排序数组 II [82] 删除排序链表中的重复元素 II [86] 分隔链表 [91] 解码方法 [92] Reverse Linked List II [93] 复原IP地址 [94] 二叉树的中序遍历 [98] 验证二叉搜索树 [103] 二叉树的锯齿形层次遍历 [116] 填充每个节点的下一个右侧节点指针 [117] 填充每个节点的下一个右侧节点指针 II [124] 二叉树中的最大路径和 [127] 单词接龙 [134] 加油站 [137] 只出现一次的数字 II [142] 环形链表 II [144] 二叉树的前序遍历 [146] LRU缓存机制 [179] Largest Number 最大数 [200] 岛屿数量 [201] 数字范围按位与 [207] 课程表 [208] 实现 Trie (前缀树) [213] 打家劫舍 II [215] 数组中的第K个最大元素 [220] 存在重复元素 III [221] 最大正方形 [238] 除自身以外数组的乘积 [316] 去除重复字母 [324] 摆动排序 II [338] 比特位计数 [341] 扁平化嵌套列表迭代器 [376] 摆动序列 [377] 组合总和 Ⅳ [402] 移掉K位数字 [424] 替换后的最长重复字符 [421] 数组中两个数的最大异或值 [495] Teemo Attacking [503] 下一个更大元素 II [525] 连续数组 [540] 有序数组中的单一元素 [554] 砖墙 [560] 和为K的子数组 [633] 平方数之和 [649] Dota2 参议院 [659] 分割数组为连续子序列 [678] 有效的括号字符串 [692] 前K个高频单词 [714] 买卖股票的最佳时机含手续费 [738] 单调递增的数字 [740] 删除与获得点数 [861] 翻转矩阵后的得分 [877] 石子游戏 [901] 股票价格跨度 [907] 子数组的最小值之和 [1004] 最大连续1的个数 III [1008] 先序遍历构造二叉树 [1011] 在 D 天内送达包裹的能力 [1094] Car Pooling [1143] 最长公共子序列 [1208] 尽可能使字符串相等 [1310] 子数组异或查询 [1395] 统计作战单位数 [1442] 形成两个异或相等数组的三元组数目 [1551] 使数组中所有元素相等的最小操作数 [1734] 解码异或后的排列 [1738] 找出第 K 大的异或坐标值 First Unique Numer Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree 合并k个排序数组 面试题 08."
}
</script><meta property="og:title" content="Medium | Leetcode-cn 笔记 | 片刻静思" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/images/icon.png">


<meta property="og:url" content="/zh/docs/notes/medium/" />




<meta property="og:description" content="[2] 两数相加 [3] 无重复字符的最长子串 [8] 字符串转换整数 (atoi) [11] 盛最多水的容器 [15] 三数之和 [16] 最接近的三数之和 [19] 删除链表的倒数第N个节点 [24] 两两交换链表中的节点 [31] 下一个排列 [33] 搜索旋转排序数组 [36] 有效的数独 [46] 全排列 [48] 旋转图像 [49] Group Anagrams，字母异位词分组 [55] 跳跃游戏 [61] 旋转链表 [62] 不同路径 [64] 最小路径和 [74] 搜索二维矩阵 [75] 颜色分类 [78] 子集 [80] 删除有序数组中的重复项 II [81] 搜索旋转排序数组 II [82] 删除排序链表中的重复元素 II [86] 分隔链表 [91] 解码方法 [92] Reverse Linked List II [93] 复原IP地址 [94] 二叉树的中序遍历 [98] 验证二叉搜索树 [103] 二叉树的锯齿形层次遍历 [116] 填充每个节点的下一个右侧节点指针 [117] 填充每个节点的下一个右侧节点指针 II [124] 二叉树中的最大路径和 [127] 单词接龙 [134] 加油站 [137] 只出现一次的数字 II [142] 环形链表 II [144] 二叉树的前序遍历 [146] LRU缓存机制 [179] Largest Number 最大数 [200] 岛屿数量 [201] 数字范围按位与 [207] 课程表 [208] 实现 Trie (前缀树) [213] 打家劫舍 II [215] 数组中的第K个最大元素 [220] 存在重复元素 III [221] 最大正方形 [238] 除自身以外数组的乘积 [316] 去除重复字母 [324] 摆动排序 II [338] 比特位计数 [341] 扁平化嵌套列表迭代器 [376] 摆动序列 [377] 组合总和 Ⅳ [402] 移掉K位数字 [424] 替换后的最长重复字符 [421] 数组中两个数的最大异或值 [495] Teemo Attacking [503] 下一个更大元素 II [525] 连续数组 [540] 有序数组中的单一元素 [554] 砖墙 [560] 和为K的子数组 [633] 平方数之和 [649] Dota2 参议院 [659] 分割数组为连续子序列 [678] 有效的括号字符串 [692] 前K个高频单词 [714] 买卖股票的最佳时机含手续费 [738] 单调递增的数字 [740] 删除与获得点数 [861] 翻转矩阵后的得分 [877] 石子游戏 [901] 股票价格跨度 [907] 子数组的最小值之和 [1004] 最大连续1的个数 III [1008] 先序遍历构造二叉树 [1011] 在 D 天内送达包裹的能力 [1094] Car Pooling [1143] 最长公共子序列 [1208] 尽可能使字符串相等 [1310] 子数组异或查询 [1395] 统计作战单位数 [1442] 形成两个异或相等数组的三元组数目 [1551] 使数组中所有元素相等的最小操作数 [1734] 解码异或后的排列 [1738] 找出第 K 大的异或坐标值 First Unique Numer Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree 合并k个排序数组 面试题 08." />




<meta property="og:locale" content="zh" />



<meta property="og:locale:alternate" content="en" />




<meta property="og:site_name" content="片刻静思" />






<meta property="article:published_time" content="2020-12-17T22:15:32&#43;08:00" />


<meta property="article:modified_time" content="2021-06-25T17:21:55&#43;08:00" />



<meta property="article:section" content="docs" />




<body class="flex flex-col min-h-screen">
    <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
        <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if ((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) {
        document.getElementsByTagName('html')[0].classList.add('dark')
    } else if (storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap p-4">
    <a href="/zh" class="mr-6 text-primary-text text-xl font-bold">片刻静思</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0" id="current-url"
            currenturl="/zh/docs/notes/medium/">
            <a href="/zh/posts/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">博文</a>
            <a href="/zh/quotation/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">摘录</a>
            <a href="/zh/docs/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">Leetcode-cn</a>
            <a href="/zh/authors/joey"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">关于</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka">Light</span>
                    <span class="px-4 py-1 hover:text-eureka">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka">Auto</span>
                </div>
            </div>
            <div class="relative pt-4 pl-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="languageMode">
                    <i class="fas fa-globe"></i>
                    <span class="pl-1">简体中文</span>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open-lang">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='languageOptions'>
                    <a class="px-4 py-1 hover:text-eureka" href="/zh/docs/notes/medium/">简体中文</a>
                    <a class="px-4 py-1 hover:text-eureka" href="/en/docs/notes/medium/">English</a>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            switchMode('Auto')
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
        switchLanguage()
    });

    let currenturl = document.getElementById('current-url').getAttribute('currenturl')
        if (currenturl.length > 1) {
            currenturl = currenturl.substr(0, currenturl.length - 1)
        }

        sessionStorage.setItem("mainKey", currenturl)

        let elements = document.getElementsByClassName('main-a');
        for (let i in elements) {
            if (typeof elements[i] === "object") {
                let elementurl = elements[i].getAttribute('href')
                if (elementurl.length > 1 && elementurl.charAt(elementurl.length - 1) == '/') {
                    elementurl = elementurl.substr(0, elementurl.length - 1)
                }
                if (elementurl == sessionStorage.getItem("mainKey")) {
                    elements[i].classList.add('text-eureka')
                } else {
                    elements[i].classList.remove('text-eureka')
                }
            }
        }
</script></div>
    </header>
    <main class="flex-grow pt-16">
        <div class="pl-scrollbar">
            <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="lg:pt-12">
    <div class="flex flex-col md:flex-row bg-secondary-bg rounded">
        <div class="md:w-1/4 lg:w-1/5 border-r">
            <div class="sticky top-16 pt-6">
                




<div id="sidebar-title" class="md:hidden mx-4 px-2 pt-4 pb-2 md:border-b text-tertiary-text md:text-primary-text">
    <span class="font-semibold">目录</span>
    <i class="fas fa-caret-right ml-1"></i>
</div>

<div id="sidebar-toc"
    class="hidden md:block overflow-y-auto mx-6 md:mx-0 pr-6 pt-2 md:max-h-doc-sidebar bg-primary-bg md:bg-transparent">
    <div class="flex flex-wrap ml-4 -mr-2 p-2 bg-secondary-bg md:bg-primary-bg rounded">
        <a class=" hover:text-eureka"
            href="/zh/docs/notes/">Leetcode-cn 笔记</a>
        
        
        


    </div>
    
<ul class="pl-6">
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" hover:text-eureka"
                href="/zh/docs/notes/easy/">Easy</a>
        </div>
        
    </li>
    
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" text-eureka  hover:text-eureka"
                href="/zh/docs/notes/medium/">Medium</a>
        </div>
        
    </li>
    
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" hover:text-eureka"
                href="/zh/docs/notes/hard/">Hard</a>
        </div>
        
    </li>
    
    
</ul>

</div>





            </div>

        </div>
        <div class="w-full md:w-3/4 lg:w-4/5 pb-8 pt-2 md:pt-8">
            <div class="w-full lg:w-3/4 pl-6 ml-0 mr-auto">
                <h1 class="font-bold text-3xl text-primary-text">Medium</h1>
                <div class="flex flex-wrap flex-row items-center my-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2020-12-17</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>13分钟阅读时长</span>
    </div>
    
    

    
</div>
            </div>
            <div class="flex">
                <div class="w-full lg:w-3/4 px-6">
                    
                    
                    <div class="content">
                        <ul>
<li><a href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0">[2] 两数相加</a></li>
<li><a href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2">[3] 无重复字符的最长子串</a></li>
<li><a href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi">[8] 字符串转换整数 (atoi)</a></li>
<li><a href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8">[11] 盛最多水的容器</a></li>
<li><a href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">[15] 三数之和</a></li>
<li><a href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">[16] 最接近的三数之和</a></li>
<li><a href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9">[19] 删除链表的倒数第N个节点</a></li>
<li><a href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9">[24] 两两交换链表中的节点</a></li>
<li><a href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97">[31] 下一个排列</a></li>
<li><a href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">[33] 搜索旋转排序数组</a></li>
<li><a href="#36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC">[36] 有效的数独</a></li>
<li><a href="#46-%E5%85%A8%E6%8E%92%E5%88%97">[46] 全排列</a></li>
<li><a href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F">[48] 旋转图像</a></li>
<li><a href="#49--group-anagrams%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84">[49]  Group Anagrams，字母异位词分组</a></li>
<li><a href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F">[55] 跳跃游戏</a></li>
<li><a href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8">[61] 旋转链表</a></li>
<li><a href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">[62] 不同路径</a></li>
<li><a href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">[64] 最小路径和</a></li>
<li><a href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5">[74] 搜索二维矩阵</a></li>
<li><a href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB">[75] 颜色分类</a></li>
<li><a href="#78-%E5%AD%90%E9%9B%86">[78] 子集</a></li>
<li><a href="#80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii">[80] 删除有序数组中的重复项 II</a></li>
<li><a href="#81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-ii">[81] 搜索旋转排序数组 II</a></li>
<li><a href="#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii">[82] 删除排序链表中的重复元素 II</a></li>
<li><a href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8">[86] 分隔链表</a></li>
<li><a href="#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95">[91] 解码方法</a></li>
<li><a href="#92-reverse-linked-list-ii">[92] Reverse Linked List II</a></li>
<li><a href="#93-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80">[93] 复原IP地址</a></li>
<li><a href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">[94] 二叉树的中序遍历</a></li>
<li><a href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">[98] 验证二叉搜索树</a></li>
<li><a href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86">[103] 二叉树的锯齿形层次遍历</a></li>
<li><a href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88">[116] 填充每个节点的下一个右侧节点指针</a></li>
<li><a href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-ii">[117] 填充每个节点的下一个右侧节点指针 II</a></li>
<li><a href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C">[124] 二叉树中的最大路径和</a></li>
<li><a href="#127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99">[127] 单词接龙</a></li>
<li><a href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99">[134] 加油站</a></li>
<li><a href="#137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-ii">[137] 只出现一次的数字 II</a></li>
<li><a href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii">[142] 环形链表 II</a></li>
<li><a href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">[144] 二叉树的前序遍历</a></li>
<li><a href="#146-lru%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">[146] LRU缓存机制</a></li>
<li><a href="#179-largest-number-%E6%9C%80%E5%A4%A7%E6%95%B0">[179] Largest Number 最大数</a></li>
<li><a href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F">[200] 岛屿数量</a></li>
<li><a href="#201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E">[201] 数字范围按位与</a></li>
<li><a href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8">[207] 课程表</a></li>
<li><a href="#208-%E5%AE%9E%E7%8E%B0-trie-%E5%89%8D%E7%BC%80%E6%A0%91">[208] 实现 Trie (前缀树)</a></li>
<li><a href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-ii">[213] 打家劫舍 II</a></li>
<li><a href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">[215] 数组中的第K个最大元素</a></li>
<li><a href="#220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-iii">[220] 存在重复元素 III</a></li>
<li><a href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2">[221] 最大正方形</a></li>
<li><a href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF">[238] 除自身以外数组的乘积</a></li>
<li><a href="#316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D">[316] 去除重复字母</a></li>
<li><a href="#324-%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F-ii">[324] 摆动排序 II</a></li>
<li><a href="#338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0">[338] 比特位计数</a></li>
<li><a href="#341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8">[341] 扁平化嵌套列表迭代器</a></li>
<li><a href="#376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97">[376] 摆动序列</a></li>
<li><a href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%B3">[377] 组合总和 Ⅳ</a></li>
<li><a href="#402-%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97">[402] 移掉K位数字</a></li>
<li><a href="#424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6">[424] 替换后的最长重复字符</a></li>
<li><a href="#421-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC">[421] 数组中两个数的最大异或值</a></li>
<li><a href="#495-teemo-attacking">[495] Teemo Attacking</a></li>
<li><a href="#503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-ii">[503] 下一个更大元素 II</a></li>
<li><a href="#525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84">[525] 连续数组</a></li>
<li><a href="#540-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0">[540] 有序数组中的单一元素</a></li>
<li><a href="#554-%E7%A0%96%E5%A2%99">[554] 砖墙</a></li>
<li><a href="#560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">[560] 和为K的子数组</a></li>
<li><a href="#633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C">[633] 平方数之和</a></li>
<li><a href="#649-dota2-%E5%8F%82%E8%AE%AE%E9%99%A2">[649] Dota2 参议院</a></li>
<li><a href="#659-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97">[659] 分割数组为连续子序列</a></li>
<li><a href="#678-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2">[678] 有效的括号字符串</a></li>
<li><a href="#692-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D">[692] 前K个高频单词</a></li>
<li><a href="#714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9">[714] 买卖股票的最佳时机含手续费</a></li>
<li><a href="#738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97">[738] 单调递增的数字</a></li>
<li><a href="#740-%E5%88%A0%E9%99%A4%E4%B8%8E%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0">[740] 删除与获得点数</a></li>
<li><a href="#861-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86">[861] 翻转矩阵后的得分</a></li>
<li><a href="#877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F">[877] 石子游戏</a></li>
<li><a href="#901-%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6">[901] 股票价格跨度</a></li>
<li><a href="#907-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C">[907] 子数组的最小值之和</a></li>
<li><a href="#1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0-iii">[1004] 最大连续1的个数 III</a></li>
<li><a href="#1008-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">[1008] 先序遍历构造二叉树</a></li>
<li><a href="#1011-%E5%9C%A8-d-%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B">[1011] 在 D 天内送达包裹的能力</a></li>
<li><a href="#1094-car-pooling">[1094] Car Pooling</a></li>
<li><a href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">[1143] 最长公共子序列</a></li>
<li><a href="#1208-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89">[1208] 尽可能使字符串相等</a></li>
<li><a href="#1310-%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2">[1310] 子数组异或查询</a></li>
<li><a href="#1395-%E7%BB%9F%E8%AE%A1%E4%BD%9C%E6%88%98%E5%8D%95%E4%BD%8D%E6%95%B0">[1395] 统计作战单位数</a></li>
<li><a href="#1442-%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE">[1442] 形成两个异或相等数组的三元组数目</a></li>
<li><a href="#1551-%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0">[1551] 使数组中所有元素相等的最小操作数</a></li>
<li><a href="#1734-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97">[1734] 解码异或后的排列</a></li>
<li><a href="#1738-%E6%89%BE%E5%87%BA%E7%AC%AC-k-%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC">[1738] 找出第 K 大的异或坐标值</a></li>
<li><a href="#first-unique-numer">First Unique Numer</a></li>
<li><a href="#check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree">Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree</a></li>
<li><a href="#%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">合并k个排序数组</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98-0804-%E5%B9%82%E9%9B%86">面试题 08.04. 幂集</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98-1620-t9%E9%94%AE%E7%9B%98">面试题 16.20. T9键盘</a></li>
</ul>
<h2 id="2-两数相加">[2] 两数相加</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers/description/">https://leetcode-cn.com/problems/add-two-numbers/description/</a></li>
</ul>
<ol>
<li>Solution1, 模拟加法运算，Time: O(max(m, n)), Space: O(1), Runtime: 99%
<ul>
<li>按位相加，<code>&gt; 9</code> 则进位，最后加上进位位</li>
</ul>
</li>
</ol>
<h2 id="3-无重复字符的最长子串">[3] 无重复字符的最长子串</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/</a></li>
</ul>
<ol>
<li>Solution 1, 双循环遍历
<ul>
<li>Runtime：13%</li>
</ul>
</li>
<li>Solution 2，双指针
<ul>
<li>[left, right]区间保存子串的左右区间，set里面是不重复的字符。</li>
<li>使用while循环，如果right字符不在set中，put; 如果right在，就把left对应的字符remove。</li>
<li>Runtime: 48%</li>
</ul>
</li>
<li>Solution 3, 保存前缀，一次遍历
<ul>
<li>当right遍历若出现重复则这个区间不符合要求，移动left到right字符上次出现的下一位置（hm.get(s.charAt(right)) + 1）</li>
<li>left更新的时候需要保留最大（最右）的位置，即left不回头</li>
<li>e.g.: 对于abba，当right指向最后的a的时候，left指向的是字典中保留的有第一个位置的a，如果不对此进行判断的话，left会移动到第一个字符b（回头）</li>
</ul>
</li>
</ol>
<h2 id="8-字符串转换整数-atoi">[8] 字符串转换整数 (atoi)</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/description/">https://leetcode-cn.com/problems/string-to-integer-atoi/description/</a></li>
<li>关键是处理各种corner case</li>
<li>trim()处理空格</li>
<li>判断第一个符号后，后面再出现符号一律归类为!Character.isDigit()</li>
</ul>
<h2 id="11-盛最多水的容器">[11] 盛最多水的容器</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/container-with-most-water/description/">https://leetcode-cn.com/problems/container-with-most-water/description/</a></li>
</ul>
<ol>
<li>Solution1: 双指针
<ul>
<li>左右指针，中间距离为边长，左右指针指向高度中短的那个为容器的高度（木桶原理），盛水容量为 <code>边长 * 高</code></li>
<li>左右往中间逼近，移动<code>height</code>小的那个指针，因为逼近过程中边长一定<code>- 1</code>，所以尽可能减弱容器高度的短板，使盛水最多</li>
</ul>
</li>
</ol>
<h2 id="15-三数之和">[15] 三数之和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/3sum/description/">https://leetcode-cn.com/problems/3sum/description/</a></li>
</ul>
<ol>
<li>Solution1, 排序+双指针, Time: O(n^2), Space: O(1), Runtime:55%
<ul>
<li>关键在于去除重复项</li>
</ul>
<ol>
<li>特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回 []</li>
<li>对数组进行排序</li>
<li>遍历排序后数组：
<ul>
<li>若 <code>nums[i]&gt;0</code>：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。</li>
<li>对于重复元素：跳过，避免出现重复解</li>
<li>令左指针 <code>l=i+1</code>，右指针 <code>r=n-1</code>，当 <code>l&lt;r</code> 时，执行循环：</li>
<li>当 <code>nums[i]+nums[l]+nums[r]==0</code>, 执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解</li>
<li>若和大于 0，说明 <code>nums[r]</code> 太大，r 左移</li>
<li>若和小于 0，说明 <code>nums[l]</code> 太小，l 右移</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="16-最接近的三数之和">[16] 最接近的三数之和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/3sum-closest/description/">https://leetcode-cn.com/problems/3sum-closest/description/</a></li>
</ul>
<ol>
<li>Solution1: 排序后遍历，双指针逼近, Time: O(n^2), Runtime: 94%
<ul>
<li>排序后从左到右，先遍历至<code>i</code>，再在<code>[i + 1, n - 1]</code>中寻找最靠近<code>target - nums[i]</code>的<code>left</code>和<code>right</code></li>
<li>优化：
<ol>
<li>遍历<code>i</code>时跳过重复</li>
<li><code>left</code>和<code>right</code>左右逼近时跳过重复</li>
<li>与<code>target</code>相等可直接<code>return</code></li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="19-删除链表的倒数第n个节点">[19] 删除链表的倒数第N个节点</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/</a></li>
<li>双指针，<code>prev</code>和<code>cur</code></li>
<li><code>cur</code>先走n步，若到尾部，则直接返回<code>head.next</code></li>
<li>若<code>cur</code>不到尾部，则<code>prev</code>也和<code>cur</code>走，直到<code>cur</code>走到尾，<code>prev</code>走到待删除的前一个node</li>
</ul>
<h2 id="24-两两交换链表中的节点">[24] 两两交换链表中的节点</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/</a></li>
</ul>
<ol>
<li>Solution1, 迭代, Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li>新建一个 <code>sentinel.next = head</code> ，使用 <code>temp</code> 从 <code>sentinel</code> 开始遍历, 遍历结束条件: <code>temp.next == null || temp.next.next == null</code></li>
<li>令 <code>node1 = temp.next, node2 = temp.next.next</code></li>
<li>核心:
<pre><code class="language-java">temp.next = node2; 
node1.next = node2.next; 
node2.next = node1; 
temp = node1;
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="31-下一个排列">[31] 下一个排列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/next-permutation/description/">https://leetcode-cn.com/problems/next-permutation/description/</a></li>
</ul>
<ol>
<li>数组从后往前遍历，找到第一个降序数字</li>
<li>与后面子序列中最小的大于它的值交换</li>
<li>将子序列倒序
<img src="https://user-images.githubusercontent.com/25404074/81701462-9d1db400-949c-11ea-9a4c-8d0b69c52351.png" alt="image"></li>
</ol>
<h2 id="33-搜索旋转排序数组">[33] 搜索旋转排序数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/</a></li>
</ul>
<ol>
<li>Solution1, 二分, Time: O(logn), Space: O(1), Runtime: 62%
<ul>
<li>做一次二分，分析应该搜索左边还是右边：</li>
</ul>
<pre><code class="language-java">if (mid &lt; right)
   右半段有序
else if (mid &gt; right)
   左半段有序
   
在有序半段判断左右区间，保留，进入再二分搜素
</code></pre>
</li>
</ol>
<h2 id="36-有效的数独">[36] 有效的数独</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-sudoku/description/">https://leetcode-cn.com/problems/valid-sudoku/description/</a></li>
<li>使用Set，关键在于校验cols, rows, cube里面数数字的唯一性</li>
<li>Cube使用<code>基数 + 浮动数</code>的方式，<code>(/ 3) * 3</code>和<code>(% 3) * 3</code>作基数，<code>/ 3</code>和 <code>% 3</code>作浮动数</li>
</ul>
<h2 id="46-全排列">[46] 全排列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/permutations/description/">https://leetcode-cn.com/problems/permutations/description/</a></li>
<li><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban</a></li>
<li>回溯法框架：
<pre><code>for 选择 in 选择列表:
  # 做选择
  将该选择从选择列表移除
  路径.add(选择)
  backtrack(路径, 选择列表)
  # 撤销选择
  路径.remove(选择)
  将该选择再加入选择列表
</code></pre>
</li>
</ul>
<h2 id="48-旋转图像">[48] 旋转图像</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/rotate-image/description/">https://leetcode-cn.com/problems/rotate-image/description/</a></li>
<li>二次调转
<ol>
<li>沿着左上右下对角线对调，选定左下角为：j = i + 1</li>
<li>沿着中轴纵线，两边对调</li>
</ol>
</li>
</ul>
<h2 id="49--group-anagrams字母异位词分组">[49]  Group Anagrams，字母异位词分组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/group-anagrams/description/">https://leetcode-cn.com/problems/group-anagrams/description/</a></li>
</ul>
<ol>
<li>Solution1, Runtime: 95%:
<ul>
<li>每个单词 <code>sorted</code> 作为 <code>key</code>
<ol>
<li>实现1: <code>value</code>为<code>List&lt;List&lt;String&gt;&gt; res</code>每个<code>List&lt;String&gt;</code>的<code>index</code></li>
<li>实现2: <code>value</code>为单独的<code>List&lt;String&gt;</code></li>
</ol>
</li>
<li>判断<code>HashMap</code>是否存在<code>key</code>，不存在则新建<code>List&lt;String&gt;</code>，存在则取该<code>List</code>，添加当前单词</li>
</ul>
</li>
<li>Solution2, Runtime: 11% :
<ul>
<li>每个单词每个字母映射成字母表 int 数组，组成唯一 String key (E.g. 1a1e1t) 作为 key</li>
</ul>
</li>
</ol>
<h2 id="55-跳跃游戏">[55] 跳跃游戏</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/jump-game/description/">https://leetcode-cn.com/problems/jump-game/description/</a></li>
<li><code>dp</code>数组中 <code>dp[i]</code> 表示达到<code>i</code>位置时剩余的跳力，若到达某个位置时跳力为负了，说明无法到达该位置。</li>
<li>到达当前位置的剩余跳力跟上一个位置的剩余跳力（<code>dp</code> 值）和上一个位置新的跳力（<code>nums</code> 数组中的值）有关。所以当前位置的剩余跳力（<code>dp</code> 值）和当前位置新的跳力中的较大那个数决定了当前能到的最远距离，而下一个位置的剩余跳力（<code>dp</code> 值）就等于当前的这个较大值减去1，因为需要花一个跳力到达下一个位置</li>
<li>所以就有状态转移方程了：<code>dp[i] = max(dp[i - 1], nums[i - 1]) - 1</code>，如果当某一个时刻 <code>dp</code> 数组的值为负了，说明无法抵达当前位置，则直接返回 <code>false</code>，最后循环结束后直接返回 <code>true </code> 即可</li>
</ul>
<h2 id="61-旋转链表">[61] 旋转链表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/rotate-list/description/">https://leetcode-cn.com/problems/rotate-list/description/</a></li>
<li>双指针<code>prev, p</code>，常规移动题</li>
<li>注意 <code>k % length</code>，不然Time Limit</li>
</ul>
<h2 id="62-不同路径">[62] 不同路径</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/unique-paths/description/">https://leetcode-cn.com/problems/unique-paths/description/</a></li>
<li>DP数组，长宽+1，第一行第一列置0，dp[1][1] = 1</li>
<li>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，统计到该点的所有路径</li>
</ul>
<h2 id="64-最小路径和">[64] 最小路径和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-path-dsum/description/">https://leetcode-cn.com/problems/minimum-path-dsum/description/</a></li>
<li>用<code>dp</code>数组记录当前行走到当前点的最小路径值，<code>dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1])</code></li>
<li><code>dp</code>第一行只能从左走，第一列只能从上走，提前初始化</li>
</ul>
<h2 id="74-搜索二维矩阵">[74] 搜索二维矩阵</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/description/">https://leetcode-cn.com/problems/search-a-2d-matrix/description/</a></li>
</ul>
<ol>
<li>Solution1, 两次查找，先确定是否在这行左右区间，再从左往右扫描, Time: O(m + n), Space: O(1), Runtime: 60%
<ul>
<li>从右上往左下角找，更显著, Runtime: 83%</li>
</ul>
</li>
<li>Solution2, 一次二分，用二分查找改进Solution1中单向遍历, Time: O(n + logM), Space: O(1), Runtime: 94%</li>
<li>Solution3, 两次二分，用二分查找改进Solution2中第一次单向遍历, Time: O(logN + logM), Space: O(1), Runtime: 94%</li>
</ol>
<h2 id="75-颜色分类">[75] 颜色分类</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/sort-colors/description/">https://leetcode-cn.com/problems/sort-colors/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/">https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/</a></li>
</ul>
<ol>
<li>Solution1: 单指针遍历两次, Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li>第一次把<code>0</code>交换到前面</li>
<li>第二次把<code>1</code>继续上面的交换到前面</li>
</ul>
</li>
<li>Solution2: 双指针遍历一次, Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li><code>p0, p1</code>分别表示<code>0</code>和<code>1</code>的位置，初始为<code>0</code></li>
<li>遇到<code>1</code>: 交换<code>nums[i], nums[p1]</code>,移动<code>p1</code></li>
<li>遇到<code>0</code>:
<ul>
<li>此情况下可能发生把前面的<code>1</code>交换到后面的情况，所以把<code>1</code>交换到后面后再交换到<code>p1</code></li>
<li>先交换<code>nums[i], nums[p0]</code>，</li>
<li>如果<code>p0 &lt; p1</code>, 再交换<code>nums[i], nums[p1]</code>,</li>
<li><code>p0</code>和<code>p1</code>均移动</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="78-子集">[78] 子集</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/subsets/description/">https://leetcode-cn.com/problems/subsets/description/</a></li>
</ul>
<h2 id="80-删除有序数组中的重复项-ii">[80] 删除有序数组中的重复项 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/description/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-yec2/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-yec2/</a></li>
</ul>
<ol>
<li>Solution1, 双指针，Time: O(n) , Space: O(1), Runtime: 28%
<ul>
<li>慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度，即 \textit{nums}[\textit{fast}]nums[fast] 表示待检查的第一个元素，\textit{nums}[\textit{slow} - 1]nums[slow−1] 为上一个应该被保留的元素所移动到的指定位置</li>
<li>需要检查上上个应该被保留的元素 nums[slow - 2] 是否和当前待检查元素 nums[fast] 相同。当且仅当 nums[slow−2]=nums[fast] 时，当前待检查元素 nums[fast] 不应该被保留（因为此时必然有 nums[slow−2]=nums[slow−1]=nums[fast]）</li>
<li>最后，slow 即为处理好的数组的长度</li>
</ul>
</li>
<li>Solution2, 双指针优雅版, Time: O(n), Space: O(1), Runtime: 78%</li>
</ol>
<h2 id="81-搜索旋转排序数组-ii">[81] 搜索旋转排序数组 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/description/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/description/</a></li>
</ul>
<ol>
<li>Solution1, 二分, Time: O(logn), Space: O(1), Runtime: 88%
<ul>
<li>解法同<a href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">[33] 搜索旋转排序数组</a></li>
<li>查找时可能会有 <code>a[l] == a[mid] == a[r]</code>，此时无法判断区间 [l,mid] 和区间 [mid+1,r] 哪个是有序的。例如 nums=[3,1,2,3,3,3,3], target=2，首次二分时无法判断区间 [0,3][0,3] 和区间 [4,6][4,6] 哪个是有序的。</li>
<li>此时，将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找</li>
</ul>
</li>
</ol>
<h2 id="82-删除排序链表中的重复元素-ii">[82] 删除排序链表中的重复元素 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/description/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/description/</a></li>
</ul>
<ol>
<li>Solution1, Time: O(n), Space: O(1), Runtime: 64%
<ul>
<li>从<code>prev</code>开始，后面的<code>next1</code>和<code>next2</code>不能重复，不然全部丢弃</li>
</ul>
</li>
</ol>
<h2 id="86-分隔链表">[86] 分隔链表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/partition-list/description/">https://leetcode-cn.com/problems/partition-list/description/</a></li>
<li>Solution1, in place
<ol>
<li>遍历到第一个大于<code>x</code>的Node <code>a</code></li>
<li>再从这里遍历到第一个小于<code>x</code>的Node <code>b</code></li>
<li><code>b</code>插到<code>a</code>之前</li>
</ol>
</li>
</ul>
<h2 id="91-解码方法">[91] 解码方法</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/decode-ways/description/">https://leetcode-cn.com/problems/decode-ways/description/</a></li>
</ul>
<ol>
<li>Solution1, DP数组, Time: O(n), Space: O(n), Runtime: 71%
<ul>
<li>DP含义：<code>dp[i]</code>表示前<code>i</code>个字符的解码方式数</li>
<li>初始条件：<code>dp[0] = 1</code>, 空字符串有一种解码方式，解析出空字符串</li>
<li>状态转移方程：
<ol>
<li>使用当前位解析一位数, 需要满足的条件: <code>s[i] != &quot;0&quot;</code>，当前解码方式数等<code>i - 1</code>解码方式数，即<code>dp[i] = dp[i - 1]</code></li>
<li>使用上一位和这一位解析两位数, 需要满足的条件：<code>s[i - 1] != &quot;0&quot; and s[i - 1] + s[i] &lt;= 26</code>, 此时 <code>dp[i] = dp[i - 2]</code></li>
</ol>
</li>
<li>终止：每一步满足条件时对<code>dp[i]</code>进行累加，最后结果为<code>dp[-1]</code></li>
</ul>
</li>
<li>Solution2, DP变量, Time: O(n), Space: O(1), Runtime: 5%</li>
</ol>
<h2 id="92-reverse-linked-list-ii">[92] Reverse Linked List II</h2>
<ul>
<li><a href="https://leetcode.com/problems/reverse-linked-list-ii/">https://leetcode.com/problems/reverse-linked-list-ii/</a></li>
</ul>
<ol>
<li>Solution1:</li>
</ol>
<ul>
<li>翻转开始前一个节点</li>
<li>翻转完成后一个节点</li>
<li>中间翻转</li>
<li>转完连接</li>
</ul>
<ol start="2">
<li>Solution2: 双指针，Runtime: 100%
<ul>
<li><code>prev</code>移动到待操作结点<code>m</code>前一个，<code>node</code>从<code>m</code>到<code>n</code>移动，每个结点都接到<code>prev</code>的后面</li>
<li>使用<code>sentinel node</code>防止在<code>list = [3, 5], m = 1, n = 2</code>的Testcase下出现<code>Null Pointer</code></li>
</ul>
</li>
</ol>
<h2 id="93-复原ip地址">[93] 复原IP地址</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/description/">https://leetcode-cn.com/problems/restore-ip-addresses/description/</a></li>
<li>递归，DFS，分一位、两位、三位三种情况</li>
</ul>
<h2 id="94-二叉树的中序遍历">[94] 二叉树的中序遍历</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/</a></li>
<li><a href="https://juejin.im/post/59e3fde451882578c20858a5">https://juejin.im/post/59e3fde451882578c20858a5</a></li>
<li>将二叉树分为“左”（包括一路向左，经过的所有实际左+根）、“右”（包括实际的右）两种节点</li>
<li>使用同样的顺序将“左”节点入栈</li>
<li>在合适的时机转向（转向后，“右”节点即成为“左”节点）、访问节点、或出栈</li>
<li>在出栈之后才访问这个节点。因为先序先访问实际根，后访问实际左，而中序恰好相反。相同的是，访问完根+左子树（先序）或左子树+根（中序）后，都需要转向到“右”节点，使“右”节点称为新的“左”节点。</li>
</ul>
<h2 id="98-验证二叉搜索树">[98] 验证二叉搜索树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/description/">https://leetcode-cn.com/problems/validate-binary-search-tree/description/</a></li>
</ul>
<ol>
<li>Solution1: 中序遍历为升序, Time: O(n), Space: O(n), Runtime: 29%
<ul>
<li>中序遍历（先左，再根，后右）结果为升序序列，则满足二叉搜索树（左子节点小于根节点，根节点小于右子节点）</li>
</ul>
</li>
<li>Solution2: 递归遍历, Time: O(n), Space: O(n), Runtime: 100%
<ul>
<li>二叉搜索树，若根结点值为<code>node.val</code>，则左子树应满足<code>node.left.val &lt; node.val</code>，即在开区间<code>(min, node.val)</code>内</li>
<li>设计递归函数<code>traverse(TreeNode node, Integer min, Integer max)</code>，若递归过程中<code>node.val &lt;= min</code> 或 <code>node.val &gt;= max</code>，直接<code>false</code></li>
<li>遍历子树: <code>traverse(node.left, min, node.val)</code>, <code>traverse(node.right, node.val, max)</code></li>
<li>Tips:
<ol>
<li>使用<code>Integer</code>而不是<code>int</code>，并判断<code>min</code>是否为<code>null</code>(无法判断<code>int</code>是否为<code>null</code>)，解决遍历到无左/右子节点的corner case</li>
<li>调用为<code>traverse(root, null, null)</code></li>
<li><code>if (node == null) return true</code>，否则无法work</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="103-二叉树的锯齿形层次遍历">[103] 二叉树的锯齿形层次遍历</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/description/">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/description/</a></li>
</ul>
<ol>
<li>Solution1, 递归，头尾插入
<ul>
<li>判断当前层数，根据奇偶对<code>List</code>进行头插或尾插</li>
</ul>
</li>
</ol>
<h2 id="116-填充每个节点的下一个右侧节点指针">[116] 填充每个节点的下一个右侧节点指针</h2>
<ol>
<li>Solution1, 使用<code>next</code>指针从上到下，从左到右连接，Time: O(n), Space: O(1), Runtime: 86%
<ul>
<li>每一层抽象成单链表，从左到右连接</li>
<li>使用上一层已经完成的连接去连接下一层</li>
</ul>
<ol>
<li>情况1: <code>left</code>和<code>right</code>在一个父结点下，<code>head.left.next = head.right</code></li>
<li>情况2: <code>left</code>和<code>right</code>不在一个父结点下，但上一层已经连接，可以通过上一层的<code>next</code>, <code>head.right.next = head.next.left</code></li>
</ol>
</li>
<li>Solution2, 递归, Time: O(n), Space: O(1), Runtime: 86%
<ul>
<li>递归，先中间走到底，再逐层向外</li>
<li>如果使用<code>parent</code>指向会导致不是父节点，同一层中间两个节点连不上</li>
<li>动图：<img src="https://cdn.jsdelivr.net/gh/joey66666/algorithms//Leetcode-cn/notes/pic/20200603221215.gif" alt=""></li>
</ul>
</li>
</ol>
<h2 id="117-填充每个节点的下一个右侧节点指针-ii">[117] 填充每个节点的下一个右侧节点指针 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/description/">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/description/</a></li>
</ul>
<ol>
<li>Solution1, 使用next指针BFS，Time: O(n), Space: O(1), Runtime: 61%
<ul>
<li>每一横向层抽象成单链表，在上一层为下一层建立 next 指针，建立完一层再继续下一层</li>
<li>使用<code>sentinel</code> node, 判断左右子结点是否存在的情况</li>
</ul>
</li>
</ol>
<h2 id="124-二叉树中的最大路径和">[124] 二叉树中的最大路径和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/description/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/description/</a></li>
<li>最大路径和 = 当前节点value + 左子树最大路径和 + 右子树最大路径和</li>
<li>如果子树路径 &lt; 0 则返回 0，否则返回 当前节点value + Math.max(左子树最大路径和 + 右子树最大路径和)</li>
<li>使用数组来保存值，如果使用变量每次递归会更新值，无法保存最大的值</li>
</ul>
<h2 id="127-单词接龙">[127] 单词接龙</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/word-ladder/description/">https://leetcode-cn.com/problems/word-ladder/description/</a></li>
<li>Solution1.1: <a href="https://www.acwing.com/solution/content/18017/">https://www.acwing.com/solution/content/18017/</a></li>
<li>Solution1.2: <a href="https://www.youtube.com/watch?v=hB_nYXFtwP0">https://www.youtube.com/watch?v=hB_nYXFtwP0</a></li>
</ul>
<ol>
<li>Solution1.1，单向BFS，Time：7%
<ul>
<li><code>Quene</code>记录当前<code>word</code>访问队列，下一邻结点需满足与<code>word</code>有且只有一个<code>char</code>不同，且未访问过，<code>HashMap</code>记录已访问过的结点及所需步数；</li>
<li>若下一邻结点为<code>endWord</code>，return当前结点步数+1；</li>
</ul>
</li>
<li>Solution1.2，单向BFS，Time：62%
<ul>
<li>对<code>queue</code>里每个邻结点，对<code>String</code>的每个<code>char</code>进行<code>a ~ z</code>字母更换匹配，若在<code>wordList</code>中则放入<code>queue</code></li>
</ul>
</li>
</ol>
<h2 id="134-加油站">[134] 加油站</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/gas-station/description/">https://leetcode-cn.com/problems/gas-station/description/</a></li>
<li><a href="https://www.youtube.com/watch?v=97CjZvrlTS4">https://www.youtube.com/watch?v=97CjZvrlTS4</a></li>
</ul>
<ol>
<li>Solution1，贪心，Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li><code>if coutn(gas) &lt; count(cost), return -1</code></li>
<li>遍历 <code>gas</code>，<code>if gas[i] + remain &lt; cost</code>，则 <code>gas[i]</code> 无法作为 <code>start</code>，跳下一位，重置 <code>remain</code></li>
<li>否则表示当前区间可用，更新 <code>remain += gas[i] - cost[i]</code>，继续遍历</li>
<li>并不需要考虑完整个 circle，只要找到一个 starting point，也就是说如果前面存在小于的情况，在总 <code>gas &gt; cost</code> 的前提下，可以 assume 后面的会得到更多的 remain，进而跑完前面的</li>
</ul>
</li>
</ol>
<h2 id="137-只出现一次的数字-ii">[137] 只出现一次的数字 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/single-number-ii/description/">https://leetcode-cn.com/problems/single-number-ii/description/</a></li>
</ul>
<ol>
<li>Solution1, dict, Time: O(n), Space: O(n), Runtime: 85%
<ul>
<li>两次遍历，一次遍历 <code>nums</code>，放次数; 一次遍历 <code>dict</code>，找次数 <code>== 1</code> 的</li>
</ul>
</li>
</ol>
<h2 id="142-环形链表-ii">[142] 环形链表 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/description/">https://leetcode-cn.com/problems/linked-list-cycle-ii/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/">https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/</a></li>
</ul>
<ol>
<li>Solution1, HashSet, Time:O(n), Space: O(n), Runtime: 21%
<ul>
<li>没法 <code>set.add(p)</code> 就是重复</li>
</ul>
</li>
<li>Solution2, 快慢指针，Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li>画图，计算得出距离的规律：从相遇点到入环点的距离加上 <code>n − 1</code> 圈的环长，恰好等于从链表头部到入环点的距离</li>
<li>当快慢指针相遇，设置另一个指针 <code>ptr</code> 从 <code>head</code> 出发， 与 <code>slow</code> 同步走，相遇的点就是入环点</li>
</ul>
</li>
</ol>
<h2 id="144-二叉树的前序遍历">[144] 二叉树的前序遍历</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/</a></li>
<li><a href="https://juejin.im/post/59e3fde451882578c20858a5">https://juejin.im/post/59e3fde451882578c20858a5</a></li>
<li>同[94] 二叉树的中序遍历 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/</a></li>
</ul>
<h2 id="146-lru缓存机制">[146] LRU缓存机制</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/lru-cache/description/">https://leetcode-cn.com/problems/lru-cache/description/</a></li>
<li>Time: O(1), Size: O(n)</li>
<li>双向链表中存储<code>Key</code>和<code>Value</code>, <code>HashMap</code>中存储<code>Key</code>和<code>Node</code></li>
<li>链表从头到尾按以旧到新，新插入放到尾，最近get放到尾，<code>HashMap.size() &gt;= capcity</code>删除头，<code>put</code>新<code>Node</code></li>
<li><img src="https://user-images.githubusercontent.com/25404074/80353709-4fa02500-88a8-11ea-90ee-770fb2ad2277.png" alt="image"></li>
</ul>
<h2 id="179-largest-number-最大数">[179] Largest Number 最大数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/largest-number/description/">https://leetcode-cn.com/problems/largest-number/description/</a></li>
</ul>
<ol>
<li>Solution1，暴力，冒泡遍历比较, Time: O(n^2), Space: O(1), Runtime: 66%
<ul>
<li>比较 <code>nums[i] + nums[j]</code> 和 <code>nums[j] + nums[i]</code> 的大小，小则交换</li>
</ul>
</li>
<li>Solution2，重写 <code>compare</code> 方法, Time: O(NlogN), Space: O(n), Runtime: 77%
<ul>
<li>Overide the Comparator to self-compare in dict order</li>
<li>if s1=&ldquo;76&rdquo;, s2=&ldquo;53&rdquo;, str1 = s1 + s2=&ldquo;7653&rdquo;, str2 = s2 + s1=&ldquo;5375&rdquo;, in which case str2 &lt; str1</li>
<li>call Arrays.Sort() with new comparator, watch the corner case with all zero</li>
</ul>
</li>
</ol>
<h2 id="200-岛屿数量">[200] 岛屿数量</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-of-islands/description/">https://leetcode-cn.com/problems/number-of-islands/description/</a></li>
</ul>
<ol>
<li>Solution1, DFS, Time: O(n^2), Space: O(n), Runtime: 83%
<ul>
<li>遇到一个岛屿，消除他的所有边界，计数</li>
<li>即，遍历，遇到的每个1，DFS，从这个1可DFS到的的所有1，置为0，计数+1，即存在一个岛屿</li>
<li>== 1 则DFS遍历每个点的上下左右，把 1 变为 0，遍历结束count += 1</li>
</ul>
</li>
</ol>
<h2 id="201-数字范围按位与">[201] 数字范围按位与</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/description/">https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/description/</a></li>
<li><a href="https://www.youtube.com/watch?v=fskPWs3Nuhc">https://www.youtube.com/watch?v=fskPWs3Nuhc</a></li>
</ul>
<ol>
<li>Solution 1
<ul>
<li>最后的数是该数字范围内所有的数的左边共同的部分</li>
<li>只要找到左边公共的部分</li>
<li>直接平移m和n，每次向右移一位，直到m和n相等</li>
<li>记录下所有平移的次数i，然后再把m左移i位即为最终结果</li>
</ul>
</li>
<li>Solution 2
<ul>
<li>从后往前每次 n = (n &amp; (n-1)), 直到n &lt;= m, 然后返回n,</li>
<li>逐渐将最右边不同的置为0, 最后只剩下最左边m 和 n相同的位置.</li>
<li>举例：110与上(110-1)，得到100，相当于去掉最低位的1，</li>
<li>n就这样每次去掉最低位的1，如果小于等于m了，返回此时的n</li>
</ul>
</li>
</ol>
<h2 id="207-课程表">[207] 课程表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/course-schedule/description/">https://leetcode-cn.com/problems/course-schedule/description/</a></li>
</ul>
<ol>
<li>Solution1, BFS
<ul>
<li><a href="https://www.youtube.com/watch?v=fskPWs3Nuhc">https://www.youtube.com/watch?v=fskPWs3Nuhc</a></li>
<li>设置出度邻接表和入度数组，构建图
<ul>
<li>邻接表结构：[index, index出度的List]</li>
</ul>
</li>
<li>设置一个Queue，放入入度为0的数a，即没有其他课程依赖该课程a</li>
<li>然后while(!Queue.isEmpty()), Queue.poll()，即BFS依赖该课程a的其他课程</li>
<li>邻接表 index==a 的List里的每个课程都-=1</li>
<li>若过程中有课程b入度为0，则放入queue</li>
<li>最后遍历入度数组，若存在&gt;0则表示该课程仍有先修课没完成，即false；遍历完true</li>
<li><img src="https://user-images.githubusercontent.com/25404074/90650728-c9508a00-e26e-11ea-9dbb-8a813cd8eb38.png" alt="image"></li>
</ul>
</li>
</ol>
<h2 id="208-实现-trie-前缀树">[208] 实现 Trie (前缀树)</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/description/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/description/</a></li>
</ul>
<ol>
<li>Solution1, 前缀树, Time: O(字符串长度)，Space: O(字符串长度)，Runtime: 18%
<ul>
<li>每一层都是字符数组[26]，每个 cell 表示指向下一个字符</li>
<li>设置一个 bool 标识当前字符是否是末尾字符</li>
</ul>
</li>
<li>Solution2, 前缀树, Time: O(字符串长度)，Space: O(字符串长度)，Runtime: 15%
<ul>
<li>每一层用 dict 实现</li>
</ul>
</li>
</ol>
<h2 id="213-打家劫舍-ii">[213] 打家劫舍 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/house-robber-ii/description/">https://leetcode-cn.com/problems/house-robber-ii/description/</a></li>
</ul>
<ol>
<li>Solution1, DP, Time: O(n), Space: O(n), Runtime: 83%
<ul>
<li>不同时触发首尾：拆成两个数组，[0, n - 1], [1, n]，取两个数组dp的最大值</li>
<li>n == 1: 返回, n == 2: 取最大值返回</li>
<li>dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])</li>
</ul>
</li>
<li>Solution2, 优化DP, 两个变量存储过程中的结果，Time: O(n), Space: O(1), Runtime: 95%
<ul>
<li>过程中只需要保存dp数组最后两个数，用变量代替</li>
</ul>
</li>
</ol>
<h2 id="215-数组中的第k个最大元素">[215] 数组中的第K个最大元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/</a></li>
</ul>
<ol>
<li>Solution1, 暴力，排序后返回, Time: O(nlogn), Space: O(n), Runtime: 81%
<ul>
<li>Time: O(nlogn) 和 Space: O(n) 都是python 自带 sorted() 方法的 Time Sort 的开销</li>
</ul>
</li>
<li>Solution2, 使用自带堆, Time: O(n), Space: O(n), Runtime: 91%
<ul>
<li>开销是构建堆和在堆查找的开销</li>
</ul>
</li>
</ol>
<h2 id="220-存在重复元素-iii">[220] 存在重复元素 III</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/description/">https://leetcode-cn.com/problems/contains-duplicate-iii/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode-bbkt/">https://leetcode-cn.com/problems/contains-duplicate-iii/solution/cun-zai-zhong-fu-yuan-su-iii-by-leetcode-bbkt/</a></li>
</ul>
<ol>
<li>Solution1, DP + 有序集合, Time: O(n * log(min(n, k))), Space: O(min(n, k)), Runtime: 43%
<ul>
<li>使用<code>DP</code>，在 <code>[i - k, i + k]</code> 内存在 index，满足 <code>nums[i] - t &lt;= index &lt;= nums[i] + t</code>，则返回 <code>true</code></li>
<li>使用有序集合，加速<code>DP</code>内部查找速度</li>
<li>使用<code>TreeSet</code>作为有序集合，<code>ceiling(set, nums[i] - t)</code>方法，返回<code>set</code>中 <code>&gt;= nums[i] - t</code> 的最小值，若不存在则返回<code>null</code></li>
<li>因为每次<code>i</code>增加，区间内 <code>k - 1</code> 个数字依然不变，所以在 <code>i &gt;= k</code> 时，移除有序集合内最老的元素，该元素值为 <code>nums[i - k]</code></li>
</ul>
</li>
</ol>
<h2 id="221-最大正方形">[221] 最大正方形</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximal-square/description/">https://leetcode-cn.com/problems/maximal-square/description/</a></li>
<li>dp[i][j]数组用来保存以matrix[i][j]为右下角的最大正方形边长</li>
</ul>
<pre><code class="language-java">if(matrix[i][j] == 1){ 
     dp[i][j] = Math.min(dp[i - 1][j],dp[i][j - 1],dp[i - 1][j - 1]) + 1
}
</code></pre>
<ul>
<li>return dp 数组中最大值的 ^2</li>
<li><img src="https://user-images.githubusercontent.com/25404074/80496729-2eb8fc00-899c-11ea-973d-8c0b39fde046.png" alt="image"></li>
</ul>
<h2 id="238-除自身以外数组的乘积">[238] 除自身以外数组的乘积</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/product-of-array-except-self/description/">https://leetcode-cn.com/problems/product-of-array-except-self/description/</a></li>
<li>从左到右遍历保存<code>nums[i]</code>左边所有数的乘积<code>res[i] = left; left *= nums[i]</code>
再从右往左遍历，右边的所有数乘积乘上左边的<code>res[i] *= right; right *= nums[i]; </code></li>
</ul>
<h2 id="316-去除重复字母">[316] 去除重复字母</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/description/">https://leetcode-cn.com/problems/remove-duplicate-letters/description/</a></li>
</ul>
<ol>
<li>Solution1: Stack
<ul>
<li>遍历，若当前字母小于栈顶字母，且后面存在栈顶字母，则弹出栈顶</li>
</ul>
</li>
</ol>
<h2 id="324-摆动排序-ii">[324] 摆动排序 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/description/">https://leetcode-cn.com/problems/wiggle-sort-ii/description/</a></li>
</ul>
<ol>
<li>Solution1, 辅助数组，排序后穿插，Time: O(n), Space: O(n), Runtime: 99%
<ul>
<li>数组按照从小到大排序后，从中间切分,比如 123456 切分后123，456 穿插进行后142536符合题意</li>
<li>但是1223这种就不行了，但是穿插规则可以变一下，两部分逆序穿插，即2 3 1 2</li>
</ul>
</li>
</ol>
<h2 id="338-比特位计数">[338] 比特位计数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/counting-bits/description/">https://leetcode-cn.com/problems/counting-bits/description/</a></li>
</ul>
<ol>
<li>Solution1, 遍历，每个num再遍历计算，Time: O(n*sizeof(integer)), Space: O(n), Runtime: 23%</li>
<li>Solution2, 利用之前计算好的，Time: O(n), Space: O(n), Runtime: 99%
<ul>
<li>i &raquo; 1会把最低位去掉，因此i &raquo; 1 也是比i小的，同样也是在前面的数组里算过。当 i 的最低位是0，则 i 中1的个数和i &raquo; 1中1的个数相同；当i的最低位是1，i 中1的个数是 i &raquo; 1中1的个数再加1</li>
</ul>
</li>
</ol>
<h2 id="341-扁平化嵌套列表迭代器">[341] 扁平化嵌套列表迭代器</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/description/">https://leetcode-cn.com/problems/flatten-nested-list-iterator/description/</a></li>
</ul>
<ol>
<li>Solution1, 递归, Time: O(n), Space: O(n), Runtime: 91%
<ul>
<li>dfs，遍历并放到数组里，遍历到 <code>Integer</code> 放进去，遍历到数组就继续 dfs 这个数组</li>
</ul>
</li>
</ol>
<h2 id="376-摆动序列">[376] 摆动序列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/wiggle-subsequence/description/">https://leetcode-cn.com/problems/wiggle-subsequence/description/</a></li>
<li><a href="https://www.acwing.com/solution/LeetCode/content/4912/">https://www.acwing.com/solution/LeetCode/content/4912/</a></li>
</ul>
<ol>
<li>Solution 1, 贪心，Time: O(n)
<ul>
<li><img src="https://user-images.githubusercontent.com/25404074/101989006-603ac980-3cd8-11eb-955e-c726b7e3ad74.png" alt="image"></li>
<li>寻找峰点（极大值）和谷点（极小值）</li>
<li>使用一个变量<code>trend</code>标记上一个元素的趋势，<code>1</code>递增，<code>-1</code>递减</li>
<li>若<code>nums[i] &gt; nums[i - 1] &amp;&amp; trend &lt; 0</code>则为谷点，<code>res += 1</code></li>
<li>若<code>nums[i] &lt; nums[i - 1] &amp;&amp; trend &gt; 0</code>则为峰点，<code>res += 1</code></li>
<li>否则为山腰点，即处于递增和递减的过程中，不计</li>
</ul>
</li>
<li>Solution 2, DP，Time: O(n)
<ul>
<li>寻找拐点</li>
<li>状态表示：<code>dp_up[n]</code>代表前<code>i</code>个元素且最后一个状态是上升的最长摆动序列长度, <code>dp_down[n]</code>代表前<code>i</code>个元素且最后一个状态是下降的最长摆动序列长度,</li>
<li>初始状态：<code>dp_up, dp_down</code>初始化为1，仅有一个元素的情况</li>
<li>状态转移：
<ul>
<li>若<code>nums[i] &gt; nums[i - 1]</code>则<code>dp_up[n] = dp_down[n - 1] + 1</code>，表示发生一次由下降到上升的转折</li>
<li>若<code>nums[i] &lt; nums[i - 1]</code>则<code>dp_down[n] = dp_up[n - 1] + 1</code>，表示发生一次由上升到下降的转折</li>
<li>否则<code>dp_up[i] = dp_up[i - 1], dp_down[i] = dp_down[i - 1]</code>，表示趋势未变，即没有转折，最长摆动序列长度保持，不增加</li>
</ul>
</li>
<li>结果表示：<code>Math.max(dp_up[n - 1], dp_down[n - 1])</code></li>
</ul>
</li>
</ol>
<h2 id="377-组合总和-">[377] 组合总和 Ⅳ</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/combination-sum-iv/description/">https://leetcode-cn.com/problems/combination-sum-iv/description/</a></li>
</ul>
<ol>
<li>Solution1, DP, Time: O(target * n), Space: O(target), Runtime: 90%
<ul>
<li>DP化：<code>dp[i]</code> 表示选取的元素之和 <code>== i</code> 的方案数量</li>
<li>初始情况: <code>dp[0] = 1</code>，都不选的情况下有一种方案可以构成 0</li>
<li>状态转移：对于 <code>[1, target]</code> 的每一个 <code>i</code>，遍历 <code>nums</code>，当 <code>num &lt;= i</code>, <code>dp[i] += dp[i - num]</code></li>
<li>边界：<code>return dp[-1]</code></li>
</ul>
</li>
</ol>
<h2 id="402-移掉k位数字">[402] 移掉K位数字</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-k-digits/description/">https://leetcode-cn.com/problems/remove-k-digits/description/</a></li>
</ul>
<ol>
<li>Solution1，贪心；
<ul>
<li>从左到右找到第一个递减的位置，将前面的大数删掉；
<ul>
<li>例如：</li>
<li>1432219 “43”位置递减，将4删掉</li>
<li>132219 “32”位置递减，将3删掉</li>
<li>12219 “21”位置递减，将2删掉</li>
<li>最后结果1219</li>
</ul>
</li>
<li>若整个数字全部是递增的，只把末尾删除；</li>
<li>不能有前导0，即”0200“，把前导0删掉，即”200“</li>
</ul>
</li>
</ol>
<h2 id="424-替换后的最长重复字符">[424] 替换后的最长重复字符</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/description/">https://leetcode-cn.com/problems/longest-repeating-character-replacement/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/">https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/</a></li>
</ul>
<ol>
<li>Solution1, 滑动窗口, Time: O(n), Space: O(1), Runtime: 89%
<ul>
<li>右边界先移动找到一个满足题意的可以替换 k 个字符以后，所有字符都变成一样的当前看来最长的子串，直到右边界纳入一个字符以后，不能满足的时候停下</li>
<li>然后考虑左边界向右移动，左边界只须要向右移动一格以后，右边界就又可以开始向右移动了，继续尝试找到更长的目标子串</li>
<li>替换后的最长重复子串就产生在右边界、左边界交替向右移动的过程中</li>
</ul>
</li>
</ol>
<h2 id="421-数组中两个数的最大异或值">[421] 数组中两个数的最大异或值</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/description/">https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-h-n9m9/">https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-h-n9m9/</a></li>
</ul>
<ol>
<li>Solutio1, HashSet, Time: O(nlogc), Space: O(n), Runtime: 73%</li>
</ol>
<h2 id="495-teemo-attacking">[495] Teemo Attacking</h2>
<ul>
<li>Compare last time + duration and current time</li>
<li>Time: O(n), Runtime: 99.3%</li>
</ul>
<h2 id="503-下一个更大元素-ii">[503] 下一个更大元素 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-ii/description/">https://leetcode-cn.com/problems/next-greater-element-ii/description/</a></li>
</ul>
<ol>
<li>Solution1, 暴力，每个数向前向后遍历两次，注意判断当前index是否已被置过</li>
<li>Solution2, 单调栈
<ol>
<li>将数组中所有元素全部置为-1</li>
<li>遍历两次，相当于循环遍历，取余进行边界回归</li>
<li>第一遍遍历，入栈索引i</li>
<li>只要后面元素比栈顶索引对应的元素大，索引出栈，更改res[sta.pop()]的数值</li>
<li>最后栈里面剩余的索引对应的数组值，都为默认的-1（因为后面未找到比它大的值） */</li>
</ol>
</li>
</ol>
<h2 id="525-连续数组">[525] 连续数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/contiguous-array/description/">https://leetcode-cn.com/problems/contiguous-array/description/</a></li>
<li>测试用例只包含0和1，遇0减1、遇1加1，存<code>sum</code>值到HashMap中，若<code>sum</code>之前存在，则说明<code>sum + 0 = sum</code>，即中间子序列和为0，即0和1个数相</li>
<li>HashMap中需要先<code>put(0, -1)</code>来使比如在<code>[0, 1]</code>上遍历<code>sum = 0</code>时<code>index = 1</code>，此时应该更新<code>res = 2</code>，而非记录为<code>index=1, res = 0</code></li>
</ul>
<h2 id="540-有序数组中的单一元素">[540] 有序数组中的单一元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/">https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/</a></li>
<li>其他成对出现，所以SingleNumber存在的序列长度为奇数</li>
<li>对于中点位置和左右进行判断，再对左右子序列中的元素个数进行判断奇偶，找到单个元素存在的方向，进行二分查找</li>
<li>注意若是偶数则 +=2 相同序列，否则 +=1</li>
<li>再搞不清打草稿列举一下（[11223],[12233],[1122334],[0112233]）</li>
</ul>
<h2 id="554-砖墙">[554] 砖墙</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/brick-wall/description/">https://leetcode-cn.com/problems/brick-wall/description/</a></li>
</ul>
<ol>
<li>Solution1，找反例, HashMap, Time: O(n * m), Space: O(n), Runtime: 84%
<ul>
<li>找穿过最少的砖块数量，就是穿过最多的砖缝数量</li>
<li>对每一层对一块砖，计算一次砖缝到左边界的距离，放入整面墙的<code>HashMap</code>中，<code>Key</code>是该砖缝到左边界距离，<code>Value</code>是出现次数</li>
<li>最后结果是 <code>砖墙高度 - 出现最多的砖缝数</code></li>
<li>最右边的砖缝不统计</li>
</ul>
</li>
</ol>
<h2 id="560-和为k的子数组">[560] 和为K的子数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/description/">https://leetcode-cn.com/problems/subarray-sum-equals-k/description/</a></li>
<li>prefixSum array 记录从0到i的前缀sum</li>
<li>subarray(i, j) = prefixSum(j) - prefixSum(i - 1)</li>
<li>找到 prefixSum(j)- prefixSum(i) == k == subarray(i, j)</li>
<li>HashMap&lt;Integer, Integer&gt;: &lt;prefixSum, prefixSum出现的次数&gt;</li>
<li>Time:O(n), Space:O(n)</li>
</ul>
<h2 id="633-平方数之和">[633] 平方数之和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">https://leetcode-cn.com/problems/sum-of-square-numbers/description/</a></li>
</ul>
<ol>
<li>Solutio1, 双指针, Time: O(n), Space: O(1), Runtime: 48%
<ul>
<li>在 [1, int(根号c + 1)] 区间内计算，结果大于 c 右指针左移，结果小于 c 左指针右移</li>
</ul>
</li>
</ol>
<h2 id="649-dota2-参议院">[649] Dota2 参议院</h2>
<ul>
<li>
<p><a href="https://leetcode-cn.com/problems/dota2-senate/description/">https://leetcode-cn.com/problems/dota2-senate/description/</a></p>
</li>
<li>
<p>Solution：char[] newSenate</p>
<ul>
<li>不是要统计数字，而是要ban到一方无法投票为止；</li>
<li>用一个新char数组记录senate，并统计两方被ban个数，有被ban则ban掉对方的senator；</li>
<li>每一轮结束查看newSenate里双方情况；</li>
<li>直到一方被ban空为止，退出循环，return另一方。</li>
</ul>
</li>
</ul>
<h2 id="659-分割数组为连续子序列">[659] 分割数组为连续子序列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/description/">https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/description/</a></li>
<li>Solution：
<ul>
<li>HashMap先统计一遍所有数字的出现频率</li>
<li>遍历数组，记录subArray的大小，遍历当前数字的下一个数，统计频率</li>
<li>若下一个数频率<code> &gt; 1</code>，即可加入现有subArray或构建新array，下一个数频率<code>-= 1</code>， 继续遍历</li>
<li>否则停止，比较subArray大小，若<code>&gt; 1 &amp;&amp; &lt; 3</code>则当前subArray不符合条件，即无法拆分原数组，<code>return false</code></li>
</ul>
</li>
</ul>
<h2 id="678-有效的括号字符串">[678] 有效的括号字符串</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/description/">https://leetcode-cn.com/problems/valid-parenthesis-string/description/</a></li>
</ul>
<ol>
<li>Solution 1
<ul>
<li>两个栈（ * 和 left ），遍历，存入index，遇到' ) &lsquo;先用 left ，再用 * 抵消，都为空则false</li>
<li>遍历完若两栈都不空，if（ index(left) &gt; index(*) ) 则为&quot; *( &ldquo;形式，无法抵消，false；若可抵消则都pop</li>
<li>若 pop 完 left 空，* 不空，* 可视为空字符串，true</li>
<li>若 pop 完 left 不空，* 空，false</li>
</ul>
</li>
<li>Solution 2
<ul>
<li>先从左往右遍历，所有 * 视为 ( ，* 和 ( 则 + 1，否则 - 1</li>
<li>若中间有 &lt; 0，则表示所有 * 不够抵消 ) ，return false</li>
<li>若遍历完 = 0，表示 * 和 ( 正好抵消 )，return true</li>
<li>若 &gt; 0 ，可能有 * 补充了没用完，进行下一步</li>
<li>下一步从右往左遍历， 所有 * 视为 ) ，* 和 ) 则 + 1，否则 - 1</li>
<li>若过程中 &lt; 0 ，( 数量大于 ), return false</li>
<li>若遍历完 = 0，* 正好抵消，return true</li>
<li>若遍历完 &gt; 0，之前一轮遍历中 * 变的 数量 ( &lt; 这一轮数量 ) ，表示部分 * 可变为 ( 或 ) 抵消，部分为空字符串, return true</li>
</ul>
</li>
</ol>
<h2 id="692-前k个高频单词">[692] 前K个高频单词</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/top-k-frequent-words/description/">https://leetcode-cn.com/problems/top-k-frequent-words/description/</a></li>
</ul>
<ol>
<li>Solution1, HashMap + Sort, Time: O(n + nlogn), Space: O(n), Runtime: 44%
<ul>
<li>HashMap&lt;k: word, v: frequency&gt;, 再两次排序，先按词字母，再按出现次数排序</li>
</ul>
</li>
<li>Solution2, Solution1的高级实现, Runtime: 85%
<ul>
<li>先统计每个单词出现的次数，再对字典进行双关键字排序
<ul>
<li>sorted 方法默认正序排列</li>
<li>第一个参数 -hash<input checked="" disabled="" type="checkbox"> 即单词出现次数的相反数, 相当于词频的倒序排列</li>
<li>当词频相同时，用第二个参数 word 进行排序，即字母正序排列</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="714-买卖股票的最佳时机含手续费">[714] 买卖股票的最佳时机含手续费</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/</a></li>
</ul>
<ol>
<li>Solution1: DP，DP数组优化为DP变量
<ul>
<li>两个变量<code>sold, hold</code>表示当天持有股票价值和卖出股票收益</li>
<li>初始状态：第一天买入，<code>hold = -prices[0], sold = 0</code>；</li>
<li>状态转移：
<ol>
<li>今天持有股票，取决于昨天持有股票或昨天今天买入新股票后两者的最大值 <code>hold = Math.max(hold, sold - prices[i])</code></li>
<li>今天卖出股票，取决于继续持有股票(不卖出)或卖出今天股票获取收益后两者的最大值 <code>sold = Math.max(sold, hold + prices[i] -fee)</code></li>
<li>最终收益为<code>sold</code></li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="738-单调递增的数字">[738] 单调递增的数字</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/description/">https://leetcode-cn.com/problems/monotone-increasing-digits/description/</a></li>
</ul>
<ol>
<li>Solution1: Greddy, Time:O(n), Runtime: 97%
<ul>
<li>从左到右遍历，找到第一个转折点(非递增位)，将该位<code>-1</code>，后面所有位置为<code>9</code></li>
</ul>
</li>
</ol>
<h2 id="740-删除与获得点数">[740] 删除与获得点数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/delete-and-earn/description/">https://leetcode-cn.com/problems/delete-and-earn/description/</a></li>
</ul>
<ol>
<li>Solution1, DP, Time: O(n + m), Space: O(m), Runtime: 50%
<ul>
<li>使用 <code>total</code> 数组，统计每个 <code>nums[i]</code> 的收益点数和，即 <code>次数 * nums[i]</code></li>
<li>在 <code>total</code> 上隔一个计算一次最大收益，最大值即为答案</li>
</ul>
</li>
</ol>
<h2 id="861-翻转矩阵后的得分">[861] 翻转矩阵后的得分</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/description/">https://leetcode-cn.com/problems/score-after-flipping-matrix/description/</a></li>
<li>Solution:
<ol>
<li>首先，翻转各行，把第一列全部置为1</li>
<li>然后，翻转各列，使各列内1数量达到最大</li>
<li>注意优化计算方式，可以在第二步同时计算结果</li>
</ol>
</li>
</ul>
<h2 id="877-石子游戏">[877] 石子游戏</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/stone-game/description/">https://leetcode-cn.com/problems/stone-game/description/</a></li>
</ul>
<ol>
<li>Solution1, 数学, Time: O(1), Space: O(1), Runtime: 72%
<ul>
<li>先手取的位置必定限制了后手能取的位置，即：先手取首位后手只能取偶数位，先手取末位后手只能取奇数位。 因此先手只需要计算好奇偶数位总和，则必赢</li>
</ul>
</li>
</ol>
<h2 id="901-股票价格跨度">[901] 股票价格跨度</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/online-stock-span/description/">https://leetcode-cn.com/problems/online-stock-span/description/</a></li>
</ul>
<ol>
<li>Solution1，暴力</li>
<li>Solution2，单调递减栈
<ul>
<li>只需要找到数字A其前面有多少个连续的并且比它小的数字个数a</li>
<li>出现数字B，当B&gt;=A时，在B前面小于等于B的连续数字共有a + 1个</li>
<li>当B &lt; A时，在B前面小于等于B的连续数字只有1个，B自己</li>
<li>两个栈，第一个保存数， 第二个保存当前的价格向前可以找连续的多少天</li>
<li>如果新来的数值大于了栈顶元素，把栈顶的元素弹出，直到当前元素小于栈顶</li>
</ul>
</li>
</ol>
<h2 id="907-子数组的最小值之和">[907] 子数组的最小值之和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/description/">https://leetcode-cn.com/problems/sum-of-subarray-minimums/description/</a></li>
</ul>
<ol>
<li>Solution1，DP，三次遍历
<ul>
<li>假设A[i]左边有L个数大于它，右边有R个数大于它</li>
<li>则以A[i]为最小数共有 (L-1)*(R-1) 个子数组</li>
<li>结果为 <code>A[i] * left[i] * right[i]</code></li>
<li>防止出现重复多算的情况，在一边计算大于等于，另一边计算大于</li>
<li>Time：O(N)</li>
<li><a href="https://leetcode.flowerplayer.com/2019/04/12/leetcode-907-sum-of-subarray-minimums-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/">https://leetcode.flowerplayer.com/2019/04/12/leetcode-907-sum-of-subarray-minimums-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/</a></li>
</ul>
</li>
<li>Solution2，单调栈，思路同[901]</li>
</ol>
<h2 id="1004-最大连续1的个数-iii">[1004] 最大连续1的个数 III</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/description/">https://leetcode-cn.com/problems/max-consecutive-ones-iii/description/</a></li>
</ul>
<ol>
<li>Solution1, 滑动窗口, Time: O(n), Space: O(1), Runtime: 94%
<ul>
<li><strong>重点：题意转换。把「最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度」转换为「找出一个最长的子数组，该子数组内最多允许有 K 个 0 」。</strong></li>
<li><strong>思路，思路，还是思路！</strong></li>
<li>右边界指针主动移，左边界指针被动移，保持区间内 <code>0</code> 的个数小于 <code>K</code>，区间长度最大值就是结果</li>
</ul>
</li>
</ol>
<h2 id="1008-先序遍历构造二叉树">[1008] 先序遍历构造二叉树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/description/">https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/description/</a></li>
<li>第一个是根，往后遍历，&lt;=根为左子树，剩下为右子树</li>
<li>递归遍历</li>
</ul>
<h2 id="1011-在-d-天内送达包裹的能力">[1011] 在 D 天内送达包裹的能力</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/description/">https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/description/</a></li>
</ul>
<ol>
<li>Solution1, 二分查找, Time: O(nlogn), Space: O(1), Runtime: 72%
<ul>
<li>船舶容量的最小值是 <code>weights</code> 里最大的，不然装不下</li>
<li>船舶容量的最大值是 <code>weights</code> 里全部加起来，这样一次就能运完</li>
<li>在最大值和最小值之间双向逼近，每一次都使用当前的容量在 <code>weights</code> 上计算运输总天数 <code>days</code>. 这里使用二分查找，时间复杂度最好
<ul>
<li>如果 <code>days &gt; D</code>, 即当前的容量不能满足 <code>D</code>，需要增加</li>
<li>否则说明容量还有压缩的空间，继续压缩</li>
</ul>
</li>
<li>每一轮计算天数：<code>count += weights[i]</code>，如果 <code>count &gt; capacity</code>, 说明 <code>weights[i]</code> 应该放到下一天，即 <code>count = weights[i], days += 1</code></li>
</ul>
</li>
</ol>
<h2 id="1094-car-pooling">[1094] Car Pooling</h2>
<ul>
<li>Use one-hot int array to record numbers at every location on and off the bus</li>
<li>Compute all the locations and compare with capacity</li>
<li>Two circle</li>
<li>Time: O(n), Runtime: 100%</li>
</ul>
<h2 id="1143-最长公共子序列">[1143] 最长公共子序列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/description/">https://leetcode-cn.com/problems/longest-common-subsequence/description/</a></li>
</ul>
<ol>
<li>Solution1, DP, Time: O(m * n), Space: O(m * n), Runtime:85%
<ul>
<li>dp[i][j]表示两个字符串在i, j之前位置（不包含i, j）的最大公共子序列长度</li>
</ul>
<pre><code class="language-java">dp[][] = new int[text1.length() + 1][text2.length() + 1]
   
if(text1.charAt(i - 1) == text2.charAt(j - 1)) {
   dp[i][j] = dp[i - 1][j - 1] + 1
}
   
else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])

</code></pre>
</li>
</ol>
<ul>
<li><img src="https://user-images.githubusercontent.com/25404074/80450199-96972480-8953-11ea-8641-656efe8beffe.png" alt="image"></li>
</ul>
<h2 id="1208-尽可能使字符串相等">[1208] 尽可能使字符串相等</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/description/">https://leetcode-cn.com/problems/get-equal-substrings-within-budget/description/</a></li>
</ul>
<ol>
<li>Solution1, 滑动窗口, Time: O(n), Space: O(1), Runtime: 94%
<ul>
<li>滑动窗口模板：双指针，右指针无脑滑，左指针看情况收缩</li>
<li>维护子数组的元素和 <code>sum</code>，初始值为 <code>0</code>。在移动两个指针的过程中，更新 <code>sum</code> 的值，判断子数组的元素和是否大于 <code>maxCost</code>，并决定是否收缩左指针</li>
</ul>
</li>
</ol>
<h2 id="1310-子数组异或查询">[1310] 子数组异或查询</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/description/">https://leetcode-cn.com/problems/xor-queries-of-a-subarray/description/</a></li>
</ul>
<ol>
<li>Solution1, 异或性质, Time: O(n), Space: O(n), Runtime: 80%
<ul>
<li><code>[l, r] = [0, l - 1] XOR [0, r]</code>
<ul>
<li>如<code>[2, 3] = [0, 1] XOR [0, 3]</code></li>
</ul>
</li>
<li>先遍历一遍 <code>attr</code>, 计算 <code>[0, r]</code>，再遍历<code>queries</code>，<code>append([l - 1] ^ [right])</code>
<ul>
<li>trick: <code>l == 0</code> 的直接返回<code>[0, r]</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="1395-统计作战单位数">[1395] 统计作战单位数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-number-of-teams/description/">https://leetcode-cn.com/problems/count-number-of-teams/description/</a></li>
</ul>
<ol>
<li>Solution1, 统计左右, <code>Time: O(n^2), Space: O(1), Runtime: 10%</code>
<ul>
<li>每一轮对中间数 <code>num</code>, 可构成的三元数组数量为 <code>左边 &lt; num的数量 * 右边 &gt; num 的数量</code> + <code>左边 &gt; num的数量 * 右边 &lt; num 的数量</code></li>
<li>一轮遍历 <code>O(n)</code>，内部两轮左右遍历 <code>O(2n)</code>，结果 <code>Time: O(2n^2) = O(n^2)</code></li>
</ul>
</li>
</ol>
<h2 id="1442-形成两个异或相等数组的三元组数目">[1442] 形成两个异或相等数组的三元组数目</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/description/">https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/description/</a></li>
</ul>
<ol>
<li>Solution1, 找规律位运算, Time: O(n^2), Space: O(1), Runtime: 64%
<ul>
<li>如果 <code>a == b</code>, 则 <code>a ^ b == 0</code>，即 <code>arr[i] ^ arr[i + 1] ^ ... ^ arr[j] ^ ... ^ arr[k] == 0</code></li>
<li><code>i &lt; j</code>, <code>j</code>可以等于<code>k</code>，要在<code>arr</code>中找到长度大于等于<code>2</code>的数组</li>
<li>如果数组中连续<code>n</code>个元素异或结果是<code>0</code>，那么组合有<code>n - 1</code>种</li>
</ul>
</li>
</ol>
<h2 id="1551-使数组中所有元素相等的最小操作数">[1551] 使数组中所有元素相等的最小操作数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal/description/">https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal/solution/shi-shu-zu-zhong-suo-you-yuan-su-xiang-deng-de-z-4/">https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal/solution/shi-shu-zu-zhong-suo-you-yuan-su-xiang-deng-de-z-4/</a></li>
</ul>
<ol>
<li>Solution1，贪心, Time: O(n), Space: O(1), Runtime: 56%
<ul>
<li>每次同时进行了「加」操作和「减」操作，只需要记录「减」操作的数量可知道操作了多少次。</li>
<li>对于每一个大于 <code>n</code> 的数，其与 <code>n</code> 的差值即为该元素需要进行的「减」操作的数量。统计所有大于 <code>n</code> 的数与 <code>n</code> 的差值</li>
</ul>
</li>
<li>Solution2，数学方法, Time: O(1), Space: O(1), Runtime: 100%
<ul>
<li>ANS展开，分奇偶，再合并，得出结果为<code>n^2 / 4</code></li>
</ul>
</li>
</ol>
<h2 id="1734-解码异或后的排列">[1734] 解码异或后的排列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/decode-xored-permutation/description/">https://leetcode-cn.com/problems/decode-xored-permutation/description/</a></li>
</ul>
<ol>
<li>Solution1, 数学规律, Time: O(n), Space: O(1) (return 不算), Runtime: 47%
<ul>
<li>读题：perm 是前 n 个正整数的排列，即 perm 里的值为[1, n]</li>
<li>关键是找到 p[0]</li>
<li>
<ol>
<li><code>p[0] ^ p[1] ^ … ^ p[n-1] = 1 ^ 2 ^ … ^ n</code></li>
</ol>
</li>
<li>
<ol start="2">
<li><code>encoded[1] ^ encode[3] ^ … ^ encoded[n-2] = (p[1] ^ p[2]) ^ (p[3] ^ p[4]) ^ … ^ (p[n-2] ^ p[n-1])</code></li>
</ol>
</li>
<li><code>1) xor 2) = p[0]</code></li>
<li><code>p[i] = p[i – 1] ^ encoded[i – 1]</code></li>
</ul>
</li>
</ol>
<h2 id="1738-找出第-k-大的异或坐标值">[1738] 找出第 K 大的异或坐标值</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/description/">https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/solution/zhao-chu-di-k-da-de-yi-huo-zuo-biao-zhi-mgick/">https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/solution/zhao-chu-di-k-da-de-yi-huo-zuo-biao-zhi-mgick/</a></li>
<li><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/solution/chi-xiao-dou-python-jian-ming-jie-ti-si-doktr/">https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/solution/chi-xiao-dou-python-jian-ming-jie-ti-si-doktr/</a></li>
</ul>
<ol>
<li>Solution1, DP, Time: O(m * n * log(mn)), Space: O(m * n), Runtime: 79%
<ul>
<li>题意转化为：求【所有子矩阵中第 k 大的异或和】</li>
<li><code>p[i][j]</code> 表示前缀和，即以<code>matrix[i][j]</code>的子矩阵运算出的异或和</li>
<li><code>p[i][j] = p[i-1][j] ^ p[i][j-1] ^ p[i-1][j-1] ^ matrix[i-1][j-1]</code></li>
</ul>
</li>
</ol>
<h2 id="first-unique-numer">First Unique Numer</h2>
<p>Medium(Maybe)</p>
<ul>
<li><a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313/">https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313/</a></li>
<li>思路同<a href="https://leetcode-cn.com/problems/lru-cache/description/">[146] LRU Cache</a></li>
<li>使用双链表 + HashMap，链表节点存<code>Key</code>，HashMap中存储<code>Key</code>和<code>Node</code>，添加时检查<code>number</code>是否为 unique ，否则的话从链表中删除。如果从HashMap中删除，可能存在单数形式被认为是unique number。</li>
<li>解决方法：不从HashMap中删除，在每次从<code>DoubleLinkedList</code>删除<code>Node</code>的逻辑里判断是否已经删除过这个<code>Node</code>了，如果已删除过，则重复，直接<code>return</code></li>
</ul>
<h2 id="check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree">Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree</h2>
<p>Medium(Maybe)</p>
<ul>
<li><a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/532/week-5/3315/">https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/532/week-5/3315/</a></li>
<li>必须从root开始，到leaf结束</li>
<li>两种情况
<ol>
<li>当前节点value != arr[i], return false;</li>
<li>arr到达末尾，树未遍历到leaf, return false;</li>
</ol>
</li>
<li>遍历左右子树，root为根有一棵子树为true则存在序列</li>
</ul>
<h2 id="合并k个排序数组">合并k个排序数组</h2>
<ul>
<li>Lintcode 486. 合并k个排序数组</li>
<li><a href="https://www.lintcode.com/problem/merge-k-sorted-arrays/">https://www.lintcode.com/problem/merge-k-sorted-arrays/</a></li>
</ul>
<ol>
<li>
<p>Solution1: 暴力</p>
<ul>
<li>使用系统自带最小堆，add一遍在poll一遍，排序交给最小堆自动完成，暴力</li>
<li>Time: O(n^2logn), Runtime: 14%</li>
<li>遍历放入后用系统内置数组排序，暴力</li>
<li>Time: O(nlogn), Runtime: 26%</li>
</ul>
</li>
<li>
<p>Solution2: 改进最小堆</p>
<ul>
<li>最小堆放入每行第一个元素，取出元素后放入该元素的右一个，直到堆为空</li>
<li>需要自定义一个数据结构表示该元素的坐标，并重写堆的Comparator</li>
<li>Time: O(nlogk)，总元素n，k行/个数组, Runtime: 64%</li>
</ul>
</li>
<li>
<p>Solution3: Merge归并</p>
<ul>
<li>合并两个数组：双指针同时遍历比较，返回合并后的数组</li>
<li>合并k个数组：对k维数组进行递归，拆解到最后每两个一组，使用合并两个数组方法两两再两两合并。结束条件为<code>left == right</code>或<code>left + 1 == right</code></li>
<li>Time: O(nlogk), Runtime: 83%</li>
</ul>
</li>
</ol>
<h2 id="面试题-0804-幂集">面试题 08.04. 幂集</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/power-set-lcci/">https://leetcode-cn.com/problems/power-set-lcci/</a></li>
<li><a href="https://wy-ei.github.io/leetcode/78-subsets/">https://wy-ei.github.io/leetcode/78-subsets/</a></li>
</ul>
<ol>
<li>Solution1, 迭代，Time: O(nlogn), Space: O(1), Runtime: 100%
<ul>
<li>初始化 <code>res</code> 加入空 <code>List</code>，每新遇到一个数，把 <code>res</code> 中所有<code>List</code>都加上这个数，组成新 <code>List</code> 再放入 <code>res</code></li>
</ul>
</li>
<li>Solution2, 位图，Time: O(n*2^n), Space: O(1), Runtime: 88%
<ul>
<li>长度为 <code>n</code> 的数组共有 <code>2 ^ n</code> 个幂集</li>
<li>把 <code>nums</code> 中的元素映射到一个表中，对应位置有元素则可放入结果中</li>
<li>这个方法，更像是数学题，找到了一种的规律</li>
<li><img src="https://github.com/joey66666/ImgHost/blob/main/leetcode/power-set-lcci-bitmap.png?raw=true" alt="位图"></li>
</ul>
</li>
</ol>
<h2 id="面试题-1620-t9键盘">面试题 16.20. T9键盘</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/t9-lcci/">https://leetcode-cn.com/problems/t9-lcci/</a></li>
</ul>
<ol>
<li>Solution1: 数组映射
<ul>
<li>使用一个 <code>char</code> 数组映射每个字母对应的数字</li>
<li>遍历，判断 <code>word</code> 每个 <code>char</code> 是否与 <code>num</code> 对应，整个 <code>word</code> 都对应加到 <code>res</code> 里</li>
</ul>
</li>
</ol>

                    </div>
                    
                    

                    

                    
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
        <span class="block font-bold">上一页</span>
        <a href="/zh/docs/notes/easy/" class="block">Easy</a>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">下一页</span>
        <a href="/zh/docs/notes/hard/" class="block">Hard</a>
        
    </div>
</div>

                    

<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zjoey" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


                </div>
                
                <div class="hidden lg:block lg:w-1/4">
                    
                    <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-secondary-bg pt-16 -mt-16 ">
    <span class="text-lg font-semibold">本页内容</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6  pt-10 -mt-10 border-l ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#2-两数相加">[2] 两数相加</a></li>
    <li><a href="#3-无重复字符的最长子串">[3] 无重复字符的最长子串</a></li>
    <li><a href="#8-字符串转换整数-atoi">[8] 字符串转换整数 (atoi)</a></li>
    <li><a href="#11-盛最多水的容器">[11] 盛最多水的容器</a></li>
    <li><a href="#15-三数之和">[15] 三数之和</a></li>
    <li><a href="#16-最接近的三数之和">[16] 最接近的三数之和</a></li>
    <li><a href="#19-删除链表的倒数第n个节点">[19] 删除链表的倒数第N个节点</a></li>
    <li><a href="#24-两两交换链表中的节点">[24] 两两交换链表中的节点</a></li>
    <li><a href="#31-下一个排列">[31] 下一个排列</a></li>
    <li><a href="#33-搜索旋转排序数组">[33] 搜索旋转排序数组</a></li>
    <li><a href="#36-有效的数独">[36] 有效的数独</a></li>
    <li><a href="#46-全排列">[46] 全排列</a></li>
    <li><a href="#48-旋转图像">[48] 旋转图像</a></li>
    <li><a href="#49--group-anagrams字母异位词分组">[49]  Group Anagrams，字母异位词分组</a></li>
    <li><a href="#55-跳跃游戏">[55] 跳跃游戏</a></li>
    <li><a href="#61-旋转链表">[61] 旋转链表</a></li>
    <li><a href="#62-不同路径">[62] 不同路径</a></li>
    <li><a href="#64-最小路径和">[64] 最小路径和</a></li>
    <li><a href="#74-搜索二维矩阵">[74] 搜索二维矩阵</a></li>
    <li><a href="#75-颜色分类">[75] 颜色分类</a></li>
    <li><a href="#78-子集">[78] 子集</a></li>
    <li><a href="#80-删除有序数组中的重复项-ii">[80] 删除有序数组中的重复项 II</a></li>
    <li><a href="#81-搜索旋转排序数组-ii">[81] 搜索旋转排序数组 II</a></li>
    <li><a href="#82-删除排序链表中的重复元素-ii">[82] 删除排序链表中的重复元素 II</a></li>
    <li><a href="#86-分隔链表">[86] 分隔链表</a></li>
    <li><a href="#91-解码方法">[91] 解码方法</a></li>
    <li><a href="#92-reverse-linked-list-ii">[92] Reverse Linked List II</a></li>
    <li><a href="#93-复原ip地址">[93] 复原IP地址</a></li>
    <li><a href="#94-二叉树的中序遍历">[94] 二叉树的中序遍历</a></li>
    <li><a href="#98-验证二叉搜索树">[98] 验证二叉搜索树</a></li>
    <li><a href="#103-二叉树的锯齿形层次遍历">[103] 二叉树的锯齿形层次遍历</a></li>
    <li><a href="#116-填充每个节点的下一个右侧节点指针">[116] 填充每个节点的下一个右侧节点指针</a></li>
    <li><a href="#117-填充每个节点的下一个右侧节点指针-ii">[117] 填充每个节点的下一个右侧节点指针 II</a></li>
    <li><a href="#124-二叉树中的最大路径和">[124] 二叉树中的最大路径和</a></li>
    <li><a href="#127-单词接龙">[127] 单词接龙</a></li>
    <li><a href="#134-加油站">[134] 加油站</a></li>
    <li><a href="#137-只出现一次的数字-ii">[137] 只出现一次的数字 II</a></li>
    <li><a href="#142-环形链表-ii">[142] 环形链表 II</a></li>
    <li><a href="#144-二叉树的前序遍历">[144] 二叉树的前序遍历</a></li>
    <li><a href="#146-lru缓存机制">[146] LRU缓存机制</a></li>
    <li><a href="#179-largest-number-最大数">[179] Largest Number 最大数</a></li>
    <li><a href="#200-岛屿数量">[200] 岛屿数量</a></li>
    <li><a href="#201-数字范围按位与">[201] 数字范围按位与</a></li>
    <li><a href="#207-课程表">[207] 课程表</a></li>
    <li><a href="#208-实现-trie-前缀树">[208] 实现 Trie (前缀树)</a></li>
    <li><a href="#213-打家劫舍-ii">[213] 打家劫舍 II</a></li>
    <li><a href="#215-数组中的第k个最大元素">[215] 数组中的第K个最大元素</a></li>
    <li><a href="#220-存在重复元素-iii">[220] 存在重复元素 III</a></li>
    <li><a href="#221-最大正方形">[221] 最大正方形</a></li>
    <li><a href="#238-除自身以外数组的乘积">[238] 除自身以外数组的乘积</a></li>
    <li><a href="#316-去除重复字母">[316] 去除重复字母</a></li>
    <li><a href="#324-摆动排序-ii">[324] 摆动排序 II</a></li>
    <li><a href="#338-比特位计数">[338] 比特位计数</a></li>
    <li><a href="#341-扁平化嵌套列表迭代器">[341] 扁平化嵌套列表迭代器</a></li>
    <li><a href="#376-摆动序列">[376] 摆动序列</a></li>
    <li><a href="#377-组合总和-">[377] 组合总和 Ⅳ</a></li>
    <li><a href="#402-移掉k位数字">[402] 移掉K位数字</a></li>
    <li><a href="#424-替换后的最长重复字符">[424] 替换后的最长重复字符</a></li>
    <li><a href="#421-数组中两个数的最大异或值">[421] 数组中两个数的最大异或值</a></li>
    <li><a href="#495-teemo-attacking">[495] Teemo Attacking</a></li>
    <li><a href="#503-下一个更大元素-ii">[503] 下一个更大元素 II</a></li>
    <li><a href="#525-连续数组">[525] 连续数组</a></li>
    <li><a href="#540-有序数组中的单一元素">[540] 有序数组中的单一元素</a></li>
    <li><a href="#554-砖墙">[554] 砖墙</a></li>
    <li><a href="#560-和为k的子数组">[560] 和为K的子数组</a></li>
    <li><a href="#633-平方数之和">[633] 平方数之和</a></li>
    <li><a href="#649-dota2-参议院">[649] Dota2 参议院</a></li>
    <li><a href="#659-分割数组为连续子序列">[659] 分割数组为连续子序列</a></li>
    <li><a href="#678-有效的括号字符串">[678] 有效的括号字符串</a></li>
    <li><a href="#692-前k个高频单词">[692] 前K个高频单词</a></li>
    <li><a href="#714-买卖股票的最佳时机含手续费">[714] 买卖股票的最佳时机含手续费</a></li>
    <li><a href="#738-单调递增的数字">[738] 单调递增的数字</a></li>
    <li><a href="#740-删除与获得点数">[740] 删除与获得点数</a></li>
    <li><a href="#861-翻转矩阵后的得分">[861] 翻转矩阵后的得分</a></li>
    <li><a href="#877-石子游戏">[877] 石子游戏</a></li>
    <li><a href="#901-股票价格跨度">[901] 股票价格跨度</a></li>
    <li><a href="#907-子数组的最小值之和">[907] 子数组的最小值之和</a></li>
    <li><a href="#1004-最大连续1的个数-iii">[1004] 最大连续1的个数 III</a></li>
    <li><a href="#1008-先序遍历构造二叉树">[1008] 先序遍历构造二叉树</a></li>
    <li><a href="#1011-在-d-天内送达包裹的能力">[1011] 在 D 天内送达包裹的能力</a></li>
    <li><a href="#1094-car-pooling">[1094] Car Pooling</a></li>
    <li><a href="#1143-最长公共子序列">[1143] 最长公共子序列</a></li>
    <li><a href="#1208-尽可能使字符串相等">[1208] 尽可能使字符串相等</a></li>
    <li><a href="#1310-子数组异或查询">[1310] 子数组异或查询</a></li>
    <li><a href="#1395-统计作战单位数">[1395] 统计作战单位数</a></li>
    <li><a href="#1442-形成两个异或相等数组的三元组数目">[1442] 形成两个异或相等数组的三元组数目</a></li>
    <li><a href="#1551-使数组中所有元素相等的最小操作数">[1551] 使数组中所有元素相等的最小操作数</a></li>
    <li><a href="#1734-解码异或后的排列">[1734] 解码异或后的排列</a></li>
    <li><a href="#1738-找出第-k-大的异或坐标值">[1738] 找出第 K 大的异或坐标值</a></li>
    <li><a href="#first-unique-numer">First Unique Numer</a></li>
    <li><a href="#check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree">Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree</a></li>
    <li><a href="#合并k个排序数组">合并k个排序数组</a></li>
    <li><a href="#面试题-0804-幂集">面试题 08.04. 幂集</a></li>
    <li><a href="#面试题-1620-t9键盘">面试题 16.20. T9键盘</a></li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
                    
                </div>
                
            </div>

        </div>


    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        hljs.initHighlightingOnLoad();
        changeSidebarHeight();
        switchDocToc();
    })
</script>









            </div>
        </div>
        
    </main>
    <footer class="pl-scrollbar">
        <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2020 <a href="https://www.zjoey.com/">z. Joey &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
    </footer>
</body>

</html>