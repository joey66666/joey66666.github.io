<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>Medium | Leetcode-cn 笔记 | 片刻静思</title>
<link rel="stylesheet" href="/css/eureka.min.css">
<script defer src="/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112541018-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-112541018-1');
</script>


<link rel="icon" type="image/png" sizes="32x32" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_2.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_2.png">

<meta name="description"
  content="
[3] 无重复字符的最长子串
[8] 字符串转换整数 (atoi)
[15] 三数之和
[19] 删除链表的倒数第N个节点
">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Leetcode 解题笔记",
      "item":"/zh/docs/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Leetcode-cn 笔记",
      "item":"/zh/docs/notes/"},{
      "@type": "ListItem",
      "position": 3 ,
      "name":"Medium",
      "item":"/zh/docs/notes/medium/"}]
}
</script><script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/zh/docs/notes/medium/"
    },
    "headline": "Medium | Leetcode-cn 笔记 | 片刻静思","datePublished": "2020-12-17T22:15:32+08:00",
    "dateModified": "2020-12-17T22:15:32+08:00",
    "wordCount":  1129 ,
    "publisher": {
        "@type": "Person",
        "name": "z. Joey",
        "logo": {
            "@type": "ImageObject",
            "url": "/images/icon.png"
        }
        },
    "description": "\u003cul\u003e\n\u003cli\u003e\u003ca href=\u0022#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2\u0022\u003e[3] 无重复字符的最长子串\u003c\/a\u003e\u003c\/li\u003e\n\u003cli\u003e\u003ca href=\u0022#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi\u0022\u003e[8] 字符串转换整数 (atoi)\u003c\/a\u003e\u003c\/li\u003e\n\u003cli\u003e\u003ca href=\u0022#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C\u0022\u003e[15] 三数之和\u003c\/a\u003e\u003c\/li\u003e\n\u003cli\u003e\u003ca href=\u0022#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9\u0022\u003e[19] 删除链表的倒数第N个节点\u003c\/a\u003e\u003c\/li\u003e\n\u003c\/ul\u003e"
}
</script><meta property="og:title" content="Medium | Leetcode-cn 笔记 | 片刻静思" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/images/icon.png">


<meta property="og:url" content="/zh/docs/notes/medium/" />




<meta property="og:description" content="
[3] 无重复字符的最长子串
[8] 字符串转换整数 (atoi)
[15] 三数之和
[19] 删除链表的倒数第N个节点
" />




<meta property="og:locale" content="zh" />



<meta property="og:locale:alternate" content="en" />




<meta property="og:site_name" content="片刻静思" />






<meta property="article:published_time" content="2020-12-17T22:15:32&#43;08:00" />


<meta property="article:modified_time" content="2020-12-17T22:15:32&#43;08:00" />



<meta property="article:section" content="docs" />




<body class="flex flex-col min-h-screen">
    <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
        <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if ((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) {
        document.getElementsByTagName('html')[0].classList.add('dark')
    } else if (storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap p-4">
    <a href="/zh" class="mr-6 text-primary-text text-xl font-bold">片刻静思</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0" id="current-url"
            currenturl="/zh/docs/notes/medium/">
            <a href="/zh/posts/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">随笔</a>
            <a href="/zh/quotation/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">摘录</a>
            <a href="/zh/docs/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">Leetcode-cn</a>
            <a href="/zh/authors/joey"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">关于</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka">Light</span>
                    <span class="px-4 py-1 hover:text-eureka">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka">Auto</span>
                </div>
            </div>
            <div class="relative pt-4 pl-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="languageMode">
                    <i class="fas fa-globe"></i>
                    <span class="pl-1">简体中文</span>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open-lang">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='languageOptions'>
                    <a class="px-4 py-1 hover:text-eureka" href="/zh/docs/notes/medium/">简体中文</a>
                    <a class="px-4 py-1 hover:text-eureka" href="/en/docs/notes/medium/">English</a>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            switchMode('Auto')
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
        switchLanguage()
    });

    let currenturl = document.getElementById('current-url').getAttribute('currenturl')
        if (currenturl.length > 1) {
            currenturl = currenturl.substr(0, currenturl.length - 1)
        }

        sessionStorage.setItem("mainKey", currenturl)

        let elements = document.getElementsByClassName('main-a');
        for (let i in elements) {
            if (typeof elements[i] === "object") {
                let elementurl = elements[i].getAttribute('href')
                if (elementurl.length > 1 && elementurl.charAt(elementurl.length - 1) == '/') {
                    elementurl = elementurl.substr(0, elementurl.length - 1)
                }
                if (elementurl == sessionStorage.getItem("mainKey")) {
                    elements[i].classList.add('text-eureka')
                } else {
                    elements[i].classList.remove('text-eureka')
                }
            }
        }
</script></div>
    </header>
    <main class="flex-grow pt-16">
        <div class="pl-scrollbar">
            <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="lg:pt-12">
    <div class="flex flex-col md:flex-row bg-secondary-bg rounded">
        <div class="md:w-1/4 lg:w-1/5 border-r">
            <div class="sticky top-16 pt-6">
                




<div id="sidebar-title" class="md:hidden mx-4 px-2 pt-4 pb-2 md:border-b text-tertiary-text md:text-primary-text">
    <span class="font-semibold">目录</span>
    <i class="fas fa-caret-right ml-1"></i>
</div>

<div id="sidebar-toc"
    class="hidden md:block overflow-y-auto mx-6 md:mx-0 pr-6 pt-2 md:max-h-doc-sidebar bg-primary-bg md:bg-transparent">
    <div class="flex flex-wrap ml-4 -mr-2 p-2 bg-secondary-bg md:bg-primary-bg rounded">
        <a class=" hover:text-eureka"
            href="/zh/docs/notes/">Leetcode-cn 笔记</a>
        
        
        


    </div>
    
<ul class="pl-6">
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" hover:text-eureka"
                href="/zh/docs/notes/easy/">Easy</a>
        </div>
        
    </li>
    
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" text-eureka  hover:text-eureka"
                href="/zh/docs/notes/medium/">Medium</a>
        </div>
        
    </li>
    
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" hover:text-eureka"
                href="/zh/docs/notes/hard/">Hard</a>
        </div>
        
    </li>
    
    
</ul>

</div>





            </div>

        </div>
        <div class="w-full md:w-3/4 lg:w-4/5 pb-8 pt-2 md:pt-8">
            <div class="w-full lg:w-3/4 pl-6 ml-0 mr-auto">
                <h1 class="font-bold text-3xl text-primary-text">Medium</h1>
                <div class="flex flex-wrap flex-row items-center my-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2020-12-17</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>6分钟阅读时长</span>
    </div>
    
    

    
</div>
            </div>
            <div class="flex">
                <div class="w-full lg:w-3/4 px-6">
                    
                    
                    <div class="content">
                        <ul>
<li><a href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2">[3] 无重复字符的最长子串</a></li>
<li><a href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi">[8] 字符串转换整数 (atoi)</a></li>
<li><a href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">[15] 三数之和</a></li>
<li><a href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9">[19] 删除链表的倒数第N个节点</a></li>
</ul>
<ul>
<li><a href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97">[31] 下一个排列</a></li>
<li><a href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">[33] 搜索旋转排序数组</a></li>
<li><a href="#36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC">[36] 有效的数独</a></li>
<li><a href="#46-%E5%85%A8%E6%8E%92%E5%88%97">[46] 全排列</a></li>
<li><a href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F">[48] 旋转图像</a></li>
<li><a href="#49--group-anagrams%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84">[49]  Group Anagrams，字母异位词分组</a></li>
<li><a href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F">[55] 跳跃游戏</a></li>
<li><a href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8">[61] 旋转链表</a></li>
<li><a href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">[62] 不同路径</a></li>
<li><a href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">[64] 最小路径和</a></li>
<li><a href="#78-%E5%AD%90%E9%9B%86">[78] 子集</a></li>
<li><a href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8">[86] 分隔链表</a></li>
<li><a href="#92-reverse-linked-list-ii">[92] Reverse Linked List II</a></li>
<li><a href="#93-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80">[93] 复原IP地址</a></li>
<li><a href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">[94] 二叉树的中序遍历</a></li>
<li><a href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88">[116] 填充每个节点的下一个右侧节点指针</a></li>
<li><a href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C">[124] 二叉树中的最大路径和</a></li>
<li><a href="#127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99">[127] 单词接龙</a></li>
<li><a href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">[144] 二叉树的前序遍历</a></li>
<li><a href="#146-lru%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">[146] LRU缓存机制</a></li>
<li><a href="#179-largest-number">[179] Largest Number</a></li>
<li><a href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F">[200] 岛屿数量</a></li>
<li><a href="#201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E">[201] 数字范围按位与</a></li>
<li><a href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8">[207] 课程表</a></li>
<li><a href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">[215] 数组中的第K个最大元素</a></li>
<li><a href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2">[221] 最大正方形</a></li>
<li><a href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF">[238] 除自身以外数组的乘积</a></li>
<li><a href="#376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97">[376] 摆动序列</a></li>
<li><a href="#402-%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97">[402] 移掉K位数字</a></li>
<li><a href="#495-teemo-attacking">[495] Teemo Attacking</a></li>
<li><a href="#503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-ii">[503] 下一个更大元素 II</a></li>
<li><a href="#525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84">[525] 连续数组</a></li>
<li><a href="#540-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0">[540] 有序数组中的单一元素</a></li>
<li><a href="#560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">[560] 和为K的子数组</a></li>
<li><a href="#649-dota2-%E5%8F%82%E8%AE%AE%E9%99%A2">[649] Dota2 参议院</a></li>
<li><a href="#659-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97">[659] 分割数组为连续子序列</a></li>
<li><a href="#678-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2">[678] 有效的括号字符串</a></li>
<li><a href="#714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9">[714] 买卖股票的最佳时机含手续费</a></li>
<li><a href="#738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97">[738] 单调递增的数字</a></li>
<li><a href="#861-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86">[861] 翻转矩阵后的得分</a></li>
<li><a href="#901-%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6">[901] 股票价格跨度</a></li>
<li><a href="#907-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C">[907] 子数组的最小值之和</a></li>
<li><a href="#1008-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">[1008] 先序遍历构造二叉树</a></li>
<li><a href="#1094-car-pooling">[1094] Car Pooling</a></li>
<li><a href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">[1143] 最长公共子序列</a></li>
<li><a href="#first-unique-numer">First Unique Numer</a></li>
<li><a href="#check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree">Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree</a></li>
</ul>
<h2 id="3-无重复字符的最长子串">[3] 无重复字符的最长子串</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/</a></li>
</ul>
<ol>
<li>Solution 1, 双循环遍历
<ul>
<li>Runtime：13%</li>
</ul>
</li>
<li>Solution 2，双指针
<ul>
<li>[left, right]区间保存子串的左右区间，set里面是不重复的字符。</li>
<li>使用while循环，如果right字符不在set中，put; 如果right在，就把left对应的字符remove。</li>
<li>Runtime: 48%</li>
</ul>
</li>
<li>Solution 3, 保存前缀，一次遍历
<ul>
<li>当right遍历若出现重复则这个区间不符合要求，移动left到right字符上次出现的下一位置（hm.get(s.charAt(right)) + 1）</li>
<li>left更新的时候需要保留最大（最右）的位置，即left不回头</li>
<li>e.g.: 对于abba，当right指向最后的a的时候，left指向的是字典中保留的有第一个位置的a，如果不对此进行判断的话，left会移动到第一个字符b（回头）</li>
</ul>
</li>
</ol>
<h2 id="8-字符串转换整数-atoi">[8] 字符串转换整数 (atoi)</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/description/">https://leetcode-cn.com/problems/string-to-integer-atoi/description/</a></li>
<li>关键是处理各种corner case</li>
<li>trim()处理空格</li>
<li>判断第一个符号后，后面再出现符号一律归类为!Character.isDigit()</li>
</ul>
<h2 id="15-三数之和">[15] 三数之和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/3sum/description/">https://leetcode-cn.com/problems/3sum/description/</a></li>
<li>Solution：滑动窗口
<ul>
<li>先排序，再找到第一个负数</li>
<li>再对剩下的区间进行左右逼近，找到三数相加等于<code>0</code>的两数。</li>
<li><strong>注意过滤相同数字：往下走一位</strong></li>
</ul>
</li>
</ul>
<h2 id="19-删除链表的倒数第n个节点">[19] 删除链表的倒数第N个节点</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/</a></li>
<li>双指针，<code>prev</code>和<code>cur</code></li>
<li><code>cur</code>先走n步，若到尾部，则直接返回<code>head.next</code></li>
<li>若<code>cur</code>不到尾部，则<code>prev</code>也和<code>cur</code>走，直到<code>cur</code>走到尾，<code>prev</code>走到待删除的前一个node</li>
</ul>
<h2 id="31-下一个排列">[31] 下一个排列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/next-permutation/description/">https://leetcode-cn.com/problems/next-permutation/description/</a></li>
</ul>
<ol>
<li>数组从后往前遍历，找到第一个降序数字</li>
<li>与后面子序列中最小的大于它的值交换</li>
<li>将子序列倒序
<img src="https://user-images.githubusercontent.com/25404074/81701462-9d1db400-949c-11ea-9a4c-8d0b69c52351.png" alt="image"></li>
</ol>
<h2 id="33-搜索旋转排序数组">[33] 搜索旋转排序数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/</a></li>
<li>做一次二分，分析应该搜索左边还是右边。每次二分有三种情况：</li>
</ul>
<ol>
<li>nums[mid] = target，则可以返回mid</li>
<li>nums[mid] &lt; nums[right]，说明在[mid, right]区间是右边递增的区间，然后判断target是否在这个区间内
<ul>
<li>如果nums[mid] &lt; target &lt;= nums[right]，说明target在右边区间里，则left = mid + 1;</li>
<li>否则在左边区间里，搜索左边区间，right = mid - 1;</li>
</ul>
</li>
<li>nums[mid] &gt;= nums[right]，说明[elft, mid]区间是在左边的递增区间，然后判断target是否在这个左边区间里
<ul>
<li>如果nums[left] &lt;= target &lt; nums[mid]，说明target在这个区间里，则使right = mid - 1;</li>
<li>否则说明target在[mid, right]的不规则区间里，搜索右边区间，则使left = mid + 1;</li>
</ul>
</li>
</ol>
<h2 id="36-有效的数独">[36] 有效的数独</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-sudoku/description/">https://leetcode-cn.com/problems/valid-sudoku/description/</a></li>
<li>使用Set，关键在于校验cols, rows, cube里面数数字的唯一性</li>
<li>Cube使用<code>基数 + 浮动数</code>的方式，<code>(/ 3) * 3</code>和<code>(% 3) * 3</code>作基数，<code>/ 3</code>和 <code>% 3</code>作浮动数</li>
</ul>
<h2 id="46-全排列">[46] 全排列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/permutations/description/">https://leetcode-cn.com/problems/permutations/description/</a></li>
<li><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban</a></li>
<li>回溯法框架：
<pre><code>for 选择 in 选择列表:
  # 做选择
  将该选择从选择列表移除
  路径.add(选择)
  backtrack(路径, 选择列表)
  # 撤销选择
  路径.remove(选择)
  将该选择再加入选择列表
</code></pre>
</li>
</ul>
<h2 id="48-旋转图像">[48] 旋转图像</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/rotate-image/description/">https://leetcode-cn.com/problems/rotate-image/description/</a></li>
<li>二次调转
<ol>
<li>沿着左上右下对角线对调，选定左下角为：j = i + 1</li>
<li>沿着中轴纵线，两边对调</li>
</ol>
</li>
</ul>
<h2 id="49--group-anagrams字母异位词分组">[49]  Group Anagrams，字母异位词分组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/group-anagrams/description/">https://leetcode-cn.com/problems/group-anagrams/description/</a></li>
</ul>
<ol>
<li>Solution1, Runtime: 95%:
<ul>
<li>每个单词 <code>sorted</code> 作为 <code>key</code>
<ol>
<li>实现1: <code>value</code>为<code>List&lt;List&lt;String&gt;&gt; res</code>每个<code>List&lt;String&gt;</code>的<code>index</code></li>
<li>实现2: <code>value</code>为单独的<code>List&lt;String&gt;</code></li>
</ol>
</li>
<li>判断<code>HashMap</code>是否存在<code>key</code>，不存在则新建<code>List&lt;String&gt;</code>，存在则取该<code>List</code>，添加当前单词</li>
</ul>
</li>
<li>Solution2, Runtime: 11% :
<ul>
<li>每个单词每个字母映射成字母表 int 数组，组成唯一 String key (E.g. 1a1e1t) 作为 key</li>
</ul>
</li>
</ol>
<h2 id="55-跳跃游戏">[55] 跳跃游戏</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/jump-game/description/">https://leetcode-cn.com/problems/jump-game/description/</a></li>
<li><code>dp</code>数组中 <code>dp[i]</code> 表示达到<code>i</code>位置时剩余的跳力，若到达某个位置时跳力为负了，说明无法到达该位置。</li>
<li>到达当前位置的剩余跳力跟上一个位置的剩余跳力（<code>dp</code> 值）和上一个位置新的跳力（<code>nums</code> 数组中的值）有关。所以当前位置的剩余跳力（<code>dp</code> 值）和当前位置新的跳力中的较大那个数决定了当前能到的最远距离，而下一个位置的剩余跳力（<code>dp</code> 值）就等于当前的这个较大值减去1，因为需要花一个跳力到达下一个位置</li>
<li>所以就有状态转移方程了：<code>dp[i] = max(dp[i - 1], nums[i - 1]) - 1</code>，如果当某一个时刻 <code>dp</code> 数组的值为负了，说明无法抵达当前位置，则直接返回 <code>false</code>，最后循环结束后直接返回 <code>true </code> 即可</li>
</ul>
<h2 id="61-旋转链表">[61] 旋转链表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/rotate-list/description/">https://leetcode-cn.com/problems/rotate-list/description/</a></li>
<li>双指针<code>prev, p</code>，常规移动题</li>
<li>注意 <code>k % length</code>，不然Time Limit</li>
</ul>
<h2 id="62-不同路径">[62] 不同路径</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/unique-paths/description/">https://leetcode-cn.com/problems/unique-paths/description/</a></li>
<li>DP数组，长宽+1，第一行第一列置0，dp[1][1] = 1</li>
<li>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，统计到该点的所有路径</li>
</ul>
<h2 id="64-最小路径和">[64] 最小路径和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-path-dsum/description/">https://leetcode-cn.com/problems/minimum-path-dsum/description/</a></li>
<li>用<code>dp</code>数组记录当前行走到当前点的最小路径值，<code>dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1])</code></li>
<li><code>dp</code>第一行只能从左走，第一列只能从上走，提前初始化</li>
</ul>
<h2 id="78-子集">[78] 子集</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/subsets/description/">https://leetcode-cn.com/problems/subsets/description/</a></li>
</ul>
<h2 id="86-分隔链表">[86] 分隔链表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/partition-list/description/">https://leetcode-cn.com/problems/partition-list/description/</a></li>
<li>Solution1, in place
<ol>
<li>遍历到第一个大于<code>x</code>的Node <code>a</code></li>
<li>再从这里遍历到第一个小于<code>x</code>的Node <code>b</code></li>
<li><code>b</code>插到<code>a</code>之前</li>
</ol>
</li>
</ul>
<h2 id="92-reverse-linked-list-ii">[92] Reverse Linked List II</h2>
<ul>
<li><a href="https://leetcode.com/problems/reverse-linked-list-ii/">https://leetcode.com/problems/reverse-linked-list-ii/</a></li>
<li>翻转开始前一个节点</li>
<li>翻转完成后一个节点</li>
<li>中间翻转</li>
<li>转完连接</li>
</ul>
<h2 id="93-复原ip地址">[93] 复原IP地址</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/description/">https://leetcode-cn.com/problems/restore-ip-addresses/description/</a></li>
<li>递归，DFS，分一位、两位、三位三种情况</li>
</ul>
<h2 id="94-二叉树的中序遍历">[94] 二叉树的中序遍历</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/</a></li>
<li><a href="https://juejin.im/post/59e3fde451882578c20858a5">https://juejin.im/post/59e3fde451882578c20858a5</a></li>
<li>将二叉树分为“左”（包括一路向左，经过的所有实际左+根）、“右”（包括实际的右）两种节点</li>
<li>使用同样的顺序将“左”节点入栈</li>
<li>在合适的时机转向（转向后，“右”节点即成为“左”节点）、访问节点、或出栈</li>
<li>在出栈之后才访问这个节点。因为先序先访问实际根，后访问实际左，而中序恰好相反。相同的是，访问完根+左子树（先序）或左子树+根（中序）后，都需要转向到“右”节点，使“右”节点称为新的“左”节点。</li>
</ul>
<h2 id="116-填充每个节点的下一个右侧节点指针">[116] 填充每个节点的下一个右侧节点指针</h2>
<ul>
<li>递归，先中间走到底，再逐层向外</li>
<li>如果使用<code>parent</code>指向会导致不是父节点，同一层中间两个节点连不上</li>
<li>动图：<img src="https://cdn.jsdelivr.net/gh/joey66666/algorithms//Leetcode-cn/notes/pic/20200603221215.gif" alt=""></li>
</ul>
<h2 id="124-二叉树中的最大路径和">[124] 二叉树中的最大路径和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/description/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/description/</a></li>
<li>最大路径和 = 当前节点value + 左子树最大路径和 + 右子树最大路径和</li>
<li>如果子树路径 &lt; 0 则返回 0，否则返回 当前节点value + Math.max(左子树最大路径和 + 右子树最大路径和)</li>
<li>使用数组来保存值，如果使用变量每次递归会更新值，无法保存最大的值</li>
</ul>
<h2 id="127-单词接龙">[127] 单词接龙</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/word-ladder/description/">https://leetcode-cn.com/problems/word-ladder/description/</a></li>
<li>Solution1.1: <a href="https://www.acwing.com/solution/content/18017/">https://www.acwing.com/solution/content/18017/</a></li>
<li>Solution1.2: <a href="https://www.youtube.com/watch?v=hB_nYXFtwP0">https://www.youtube.com/watch?v=hB_nYXFtwP0</a></li>
</ul>
<ol>
<li>Solution1.1，单向BFS，Time：7%
<ul>
<li><code>Quene</code>记录当前<code>word</code>访问队列，下一邻结点需满足与<code>word</code>有且只有一个<code>char</code>不同，且未访问过，<code>HashMap</code>记录已访问过的结点及所需步数；</li>
<li>若下一邻结点为<code>endWord</code>，return当前结点步数+1；</li>
</ul>
</li>
<li>Solution1.2，单向BFS，Time：62%
<ul>
<li>对<code>queue</code>里每个邻结点，对<code>String</code>的每个<code>char</code>进行<code>a ~ z</code>字母更换匹配，若在<code>wordList</code>中则放入<code>queue</code></li>
</ul>
</li>
</ol>
<h2 id="144-二叉树的前序遍历">[144] 二叉树的前序遍历</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/</a></li>
<li><a href="https://juejin.im/post/59e3fde451882578c20858a5">https://juejin.im/post/59e3fde451882578c20858a5</a></li>
<li>同[94] 二叉树的中序遍历 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/</a></li>
</ul>
<h2 id="146-lru缓存机制">[146] LRU缓存机制</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/lru-cache/description/">https://leetcode-cn.com/problems/lru-cache/description/</a></li>
<li>Time: O(1), Size: O(n)</li>
<li>双向链表中存储<code>Key</code>和<code>Value</code>, <code>HashMap</code>中存储<code>Key</code>和<code>Node</code></li>
<li>链表从头到尾按以旧到新，新插入放到尾，最近get放到尾，<code>HashMap.size() &gt;= capcity</code>删除头，<code>put</code>新<code>Node</code></li>
<li><img src="https://user-images.githubusercontent.com/25404074/80353709-4fa02500-88a8-11ea-90ee-770fb2ad2277.png" alt="image"></li>
</ul>
<h2 id="179-largest-number">[179] Largest Number</h2>
<ul>
<li>Overide the Comparator to self-compare in dict order</li>
<li>e.g.:
<ul>
<li>if s1=&ldquo;76&rdquo;, s2=&ldquo;53&rdquo;, str1 = s1 + s2=&ldquo;7653&rdquo;, str2 = s2 + s1=&ldquo;5375&rdquo;</li>
<li>in which case str2 &lt; str1</li>
<li>call Arrays.Sort() with new comparator</li>
<li>watch the corner case with all zero</li>
</ul>
</li>
</ul>
<h2 id="200-岛屿数量">[200] 岛屿数量</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-of-islands/description/">https://leetcode-cn.com/problems/number-of-islands/description/</a></li>
<li>== 1 则DFS遍历每个点的上下左右，把 1 变为 0，遍历结束count += 1</li>
</ul>
<h2 id="201-数字范围按位与">[201] 数字范围按位与</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/description/">https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/description/</a></li>
<li><a href="https://www.youtube.com/watch?v=fskPWs3Nuhc">https://www.youtube.com/watch?v=fskPWs3Nuhc</a></li>
</ul>
<ol>
<li>Solution 1
<ul>
<li>最后的数是该数字范围内所有的数的左边共同的部分</li>
<li>只要找到左边公共的部分</li>
<li>直接平移m和n，每次向右移一位，直到m和n相等</li>
<li>记录下所有平移的次数i，然后再把m左移i位即为最终结果</li>
</ul>
</li>
<li>Solution 2
<ul>
<li>从后往前每次 n = (n &amp; (n-1)), 直到n &lt;= m, 然后返回n,</li>
<li>逐渐将最右边不同的置为0, 最后只剩下最左边m 和 n相同的位置.</li>
<li>举例：110与上(110-1)，得到100，相当于去掉最低位的1，</li>
<li>n就这样每次去掉最低位的1，如果小于等于m了，返回此时的n</li>
</ul>
</li>
</ol>
<h2 id="207-课程表">[207] 课程表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/course-schedule/description/">https://leetcode-cn.com/problems/course-schedule/description/</a></li>
</ul>
<ol>
<li>Solution1, BFS
<ul>
<li><a href="https://www.youtube.com/watch?v=fskPWs3Nuhc">https://www.youtube.com/watch?v=fskPWs3Nuhc</a></li>
<li>设置出度邻接表和入度数组，构建图
<ul>
<li>邻接表结构：[index, index出度的List]</li>
</ul>
</li>
<li>设置一个Queue，放入入度为0的数a，即没有其他课程依赖该课程a</li>
<li>然后while(!Queue.isEmpty()), Queue.poll()，即BFS依赖该课程a的其他课程</li>
<li>邻接表 index==a 的List里的每个课程都-=1</li>
<li>若过程中有课程b入度为0，则放入queue</li>
<li>最后遍历入度数组，若存在&gt;0则表示该课程仍有先修课没完成，即false；遍历完true</li>
<li><img src="https://user-images.githubusercontent.com/25404074/90650728-c9508a00-e26e-11ea-9dbb-8a813cd8eb38.png" alt="image"></li>
</ul>
</li>
</ol>
<h2 id="215-数组中的第k个最大元素">[215] 数组中的第K个最大元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/</a></li>
<li>先排序再输出，<code>Arrays.sort()</code>升序排列</li>
</ul>
<h2 id="221-最大正方形">[221] 最大正方形</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximal-square/description/">https://leetcode-cn.com/problems/maximal-square/description/</a></li>
<li>dp[i][j]数组用来保存以matrix[i][j]为右下角的最大正方形边长</li>
</ul>
<pre><code class="language-java">if(matrix[i][j] == 1){ 
     dp[i][j] = Math.min(dp[i - 1][j],dp[i][j - 1],dp[i - 1][j - 1]) + 1
}
</code></pre>
<ul>
<li>return dp 数组中最大值的 ^2</li>
<li><img src="https://user-images.githubusercontent.com/25404074/80496729-2eb8fc00-899c-11ea-973d-8c0b39fde046.png" alt="image"></li>
</ul>
<h2 id="238-除自身以外数组的乘积">[238] 除自身以外数组的乘积</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/product-of-array-except-self/description/">https://leetcode-cn.com/problems/product-of-array-except-self/description/</a></li>
<li>从左到右遍历保存<code>nums[i]</code>左边所有数的乘积<code>res[i] = left; left *= nums[i]</code>
再从右往左遍历，右边的所有数乘积乘上左边的<code>res[i] *= right; right *= nums[i]; </code></li>
</ul>
<h2 id="376-摆动序列">[376] 摆动序列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/wiggle-subsequence/description/">https://leetcode-cn.com/problems/wiggle-subsequence/description/</a></li>
<li><a href="https://www.acwing.com/solution/LeetCode/content/4912/">https://www.acwing.com/solution/LeetCode/content/4912/</a></li>
</ul>
<ol>
<li>Solution 1, 贪心，Time: O(n)
<ul>
<li><img src="https://user-images.githubusercontent.com/25404074/101989006-603ac980-3cd8-11eb-955e-c726b7e3ad74.png" alt="image"></li>
<li>寻找峰点（极大值）和谷点（极小值）</li>
<li>使用一个变量<code>trend</code>标记上一个元素的趋势，<code>1</code>递增，<code>-1</code>递减</li>
<li>若<code>nums[i] &gt; nums[i - 1] &amp;&amp; trend &lt; 0</code>则为谷点，<code>res += 1</code></li>
<li>若<code>nums[i] &lt; nums[i - 1] &amp;&amp; trend &gt; 0</code>则为峰点，<code>res += 1</code></li>
<li>否则为山腰点，即处于递增和递减的过程中，不计</li>
</ul>
</li>
<li>Solution 2, DP，Time: O(n)
<ul>
<li>寻找拐点</li>
<li>状态表示：<code>dp_up[n]</code>代表前<code>i</code>个元素且最后一个状态是上升的最长摆动序列长度, <code>dp_down[n]</code>代表前<code>i</code>个元素且最后一个状态是下降的最长摆动序列长度,</li>
<li>初始状态：<code>dp_up, dp_down</code>初始化为1，仅有一个元素的情况</li>
<li>状态转移：
<ul>
<li>若<code>nums[i] &gt; nums[i - 1]</code>则<code>dp_up[n] = dp_down[n - 1] + 1</code>，表示发生一次由下降到上升的转折</li>
<li>若<code>nums[i] &lt; nums[i - 1]</code>则<code>dp_down[n] = dp_up[n - 1] + 1</code>，表示发生一次由上升到下降的转折</li>
<li>否则<code>dp_up[i] = dp_up[i - 1], dp_down[i] = dp_down[i - 1]</code>，表示趋势未变，即没有转折，最长摆动序列长度保持，不增加</li>
</ul>
</li>
<li>结果表示：<code>Math.max(dp_up[n - 1], dp_down[n - 1])</code></li>
</ul>
</li>
</ol>
<h2 id="402-移掉k位数字">[402] 移掉K位数字</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-k-digits/description/">https://leetcode-cn.com/problems/remove-k-digits/description/</a></li>
</ul>
<ol>
<li>Solution1，贪心；
<ul>
<li>从左到右找到第一个递减的位置，将前面的大数删掉；
<ul>
<li>例如：</li>
<li>1432219 “43”位置递减，将4删掉</li>
<li>132219 “32”位置递减，将3删掉</li>
<li>12219 “21”位置递减，将2删掉</li>
<li>最后结果1219</li>
</ul>
</li>
<li>若整个数字全部是递增的，只把末尾删除；</li>
<li>不能有前导0，即”0200“，把前导0删掉，即”200“</li>
</ul>
</li>
</ol>
<h2 id="495-teemo-attacking">[495] Teemo Attacking</h2>
<ul>
<li>Compare last time + duration and current time</li>
<li>Time: O(n), Runtime: 99.3%</li>
</ul>
<h2 id="503-下一个更大元素-ii">[503] 下一个更大元素 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-ii/description/">https://leetcode-cn.com/problems/next-greater-element-ii/description/</a></li>
</ul>
<ol>
<li>Solution1, 暴力，每个数向前向后遍历两次，注意判断当前index是否已被置过</li>
<li>Solution2, 单调栈
<ol>
<li>将数组中所有元素全部置为-1</li>
<li>遍历两次，相当于循环遍历，取余进行边界回归</li>
<li>第一遍遍历，入栈索引i</li>
<li>只要后面元素比栈顶索引对应的元素大，索引出栈，更改res[sta.pop()]的数值</li>
<li>最后栈里面剩余的索引对应的数组值，都为默认的-1（因为后面未找到比它大的值） */</li>
</ol>
</li>
</ol>
<h2 id="525-连续数组">[525] 连续数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/contiguous-array/description/">https://leetcode-cn.com/problems/contiguous-array/description/</a></li>
<li>测试用例只包含0和1，遇0减1、遇1加1，存<code>sum</code>值到HashMap中，若<code>sum</code>之前存在，则说明<code>sum + 0 = sum</code>，即中间子序列和为0，即0和1个数相</li>
<li>HashMap中需要先<code>put(0, -1)</code>来使比如在<code>[0, 1]</code>上遍历<code>sum = 0</code>时<code>index = 1</code>，此时应该更新<code>res = 2</code>，而非记录为<code>index=1, res = 0</code></li>
</ul>
<h2 id="540-有序数组中的单一元素">[540] 有序数组中的单一元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/">https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/</a></li>
<li>其他成对出现，所以SingleNumber存在的序列长度为奇数</li>
<li>对于中点位置和左右进行判断，再对左右子序列中的元素个数进行判断奇偶，找到单个元素存在的方向，进行二分查找</li>
<li>注意若是偶数则 +=2 相同序列，否则 +=1</li>
<li>再搞不清打草稿列举一下（[11223],[12233],[1122334],[0112233]）</li>
</ul>
<h2 id="560-和为k的子数组">[560] 和为K的子数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/description/">https://leetcode-cn.com/problems/subarray-sum-equals-k/description/</a></li>
<li>prefixSum array 记录从0到i的前缀sum</li>
<li>subarray(i, j) = prefixSum(j) - prefixSum(i - 1)</li>
<li>找到 prefixSum(j)- prefixSum(i) == k == subarray(i, j)</li>
<li>HashMap&lt;Integer, Integer&gt;: &lt;prefixSum, prefixSum出现的次数&gt;</li>
<li>Time:O(n), Space:O(n)</li>
</ul>
<h2 id="649-dota2-参议院">[649] Dota2 参议院</h2>
<ul>
<li>
<p><a href="https://leetcode-cn.com/problems/dota2-senate/description/">https://leetcode-cn.com/problems/dota2-senate/description/</a></p>
</li>
<li>
<p>Solution：char[] newSenate</p>
<ul>
<li>不是要统计数字，而是要ban到一方无法投票为止；</li>
<li>用一个新char数组记录senate，并统计两方被ban个数，有被ban则ban掉对方的senator；</li>
<li>每一轮结束查看newSenate里双方情况；</li>
<li>直到一方被ban空为止，退出循环，return另一方。</li>
</ul>
</li>
</ul>
<h2 id="659-分割数组为连续子序列">[659] 分割数组为连续子序列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/description/">https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/description/</a></li>
<li>Solution：
<ul>
<li>HashMap先统计一遍所有数字的出现频率</li>
<li>遍历数组，记录subArray的大小，遍历当前数字的下一个数，统计频率</li>
<li>若下一个数频率<code> &gt; 1</code>，即可加入现有subArray或构建新array，下一个数频率<code>-= 1</code>， 继续遍历</li>
<li>否则停止，比较subArray大小，若<code>&gt; 1 &amp;&amp; &lt; 3</code>则当前subArray不符合条件，即无法拆分原数组，<code>return false</code></li>
</ul>
</li>
</ul>
<h2 id="678-有效的括号字符串">[678] 有效的括号字符串</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/description/">https://leetcode-cn.com/problems/valid-parenthesis-string/description/</a></li>
</ul>
<ol>
<li>Solution 1
<ul>
<li>两个栈（ * 和 left ），遍历，存入index，遇到' ) &lsquo;先用 left ，再用 * 抵消，都为空则false</li>
<li>遍历完若两栈都不空，if（ index(left) &gt; index(*) ) 则为&quot; *( &ldquo;形式，无法抵消，false；若可抵消则都pop</li>
<li>若 pop 完 left 空，* 不空，* 可视为空字符串，true</li>
<li>若 pop 完 left 不空，* 空，false</li>
</ul>
</li>
<li>Solution 2
<ul>
<li>先从左往右遍历，所有 * 视为 ( ，* 和 ( 则 + 1，否则 - 1</li>
<li>若中间有 &lt; 0，则表示所有 * 不够抵消 ) ，return false</li>
<li>若遍历完 = 0，表示 * 和 ( 正好抵消 )，return true</li>
<li>若 &gt; 0 ，可能有 * 补充了没用完，进行下一步</li>
<li>下一步从右往左遍历， 所有 * 视为 ) ，* 和 ) 则 + 1，否则 - 1</li>
<li>若过程中 &lt; 0 ，( 数量大于 ), return false</li>
<li>若遍历完 = 0，* 正好抵消，return true</li>
<li>若遍历完 &gt; 0，之前一轮遍历中 * 变的 数量 ( &lt; 这一轮数量 ) ，表示部分 * 可变为 ( 或 ) 抵消，部分为空字符串, return true</li>
</ul>
</li>
</ol>
<h2 id="714-买卖股票的最佳时机含手续费">[714] 买卖股票的最佳时机含手续费</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/</a></li>
</ul>
<ol>
<li>Solution1: DP，DP数组优化为DP变量
<ul>
<li>两个变量<code>sold, hold</code>表示当天持有股票价值和卖出股票收益</li>
<li>初始状态：第一天买入，<code>hold = -prices[0], sold = 0</code>；</li>
<li>状态转移：
<ol>
<li>今天持有股票，取决于昨天持有股票或昨天今天买入新股票后两者的最大值 <code>hold = Math.max(hold, sold - prices[i])</code></li>
<li>今天卖出股票，取决于继续持有股票(不卖出)或卖出今天股票获取收益后两者的最大值 <code>sold = Math.max(sold, hold + prices[i] -fee)</code></li>
<li>最终收益为<code>sold</code></li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="738-单调递增的数字">[738] 单调递增的数字</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/description/">https://leetcode-cn.com/problems/monotone-increasing-digits/description/</a></li>
</ul>
<ol>
<li>Solution1: Greddy, Time:O(n), Runtime: 97%
<ul>
<li>从左到右遍历，找到第一个转折点(非递增位)，将该位<code>-1</code>，后面所有位置为<code>9</code></li>
</ul>
</li>
</ol>
<h2 id="861-翻转矩阵后的得分">[861] 翻转矩阵后的得分</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/description/">https://leetcode-cn.com/problems/score-after-flipping-matrix/description/</a></li>
<li>Solution:
<ol>
<li>首先，翻转各行，把第一列全部置为1</li>
<li>然后，翻转各列，使各列内1数量达到最大</li>
<li>注意优化计算方式，可以在第二步同时计算结果</li>
</ol>
</li>
</ul>
<h2 id="901-股票价格跨度">[901] 股票价格跨度</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/online-stock-span/description/">https://leetcode-cn.com/problems/online-stock-span/description/</a></li>
</ul>
<ol>
<li>Solution1，暴力</li>
<li>Solution2，单调递减栈
<ul>
<li>只需要找到数字A其前面有多少个连续的并且比它小的数字个数a</li>
<li>出现数字B，当B&gt;=A时，在B前面小于等于B的连续数字共有a + 1个</li>
<li>当B &lt; A时，在B前面小于等于B的连续数字只有1个，B自己</li>
<li>两个栈，第一个保存数， 第二个保存当前的价格向前可以找连续的多少天</li>
<li>如果新来的数值大于了栈顶元素，把栈顶的元素弹出，直到当前元素小于栈顶</li>
</ul>
</li>
</ol>
<h2 id="907-子数组的最小值之和">[907] 子数组的最小值之和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/description/">https://leetcode-cn.com/problems/sum-of-subarray-minimums/description/</a></li>
</ul>
<ol>
<li>Solution1，DP，三次遍历
<ul>
<li>假设A[i]左边有L个数大于它，右边有R个数大于它</li>
<li>则以A[i]为最小数共有 (L-1)*(R-1) 个子数组</li>
<li>结果为 <code>A[i] * left[i] * right[i]</code></li>
<li>防止出现重复多算的情况，在一边计算大于等于，另一边计算大于</li>
<li>Time：O(N)</li>
<li><a href="https://leetcode.flowerplayer.com/2019/04/12/leetcode-907-sum-of-subarray-minimums-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/">https://leetcode.flowerplayer.com/2019/04/12/leetcode-907-sum-of-subarray-minimums-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/</a></li>
</ul>
</li>
<li>Solution2，单调栈，思路同[901]</li>
</ol>
<h2 id="1008-先序遍历构造二叉树">[1008] 先序遍历构造二叉树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/description/">https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/description/</a></li>
<li>第一个是根，往后遍历，&lt;=根为左子树，剩下为右子树</li>
<li>递归遍历</li>
</ul>
<h2 id="1094-car-pooling">[1094] Car Pooling</h2>
<ul>
<li>Use one-hot int array to record numbers at every location on and off the bus</li>
<li>Compute all the locations and compare with capacity</li>
<li>Two circle</li>
<li>Time: O(n), Runtime: 100%</li>
</ul>
<h2 id="1143-最长公共子序列">[1143] 最长公共子序列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/description/">https://leetcode-cn.com/problems/longest-common-subsequence/description/</a></li>
<li>dp[text1.length() + 1][text2.length() + 1]</li>
<li>dp[i][j]表示两个字符串在i, j之前位置（不包含i, j）的最大公共子序列长度</li>
<li>if(text1.charAt(i - 1) == text2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + 1</li>
<li>else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])</li>
<li><img src="https://user-images.githubusercontent.com/25404074/80450199-96972480-8953-11ea-8641-656efe8beffe.png" alt="image"></li>
</ul>
<h2 id="first-unique-numer">First Unique Numer</h2>
<p>Medium(Maybe)</p>
<ul>
<li><a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313/">https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313/</a></li>
<li>思路同<a href="https://leetcode-cn.com/problems/lru-cache/description/">[146] LRU Cache</a></li>
<li>使用双链表 + HashMap，链表节点存<code>Key</code>，HashMap中存储<code>Key</code>和<code>Node</code>，添加时检查<code>number</code>是否为 unique ，否则的话从链表中删除。如果从HashMap中删除，可能存在单数形式被认为是unique number。</li>
<li>解决方法：不从HashMap中删除，在每次从<code>DoubleLinkedList</code>删除<code>Node</code>的逻辑里判断是否已经删除过这个<code>Node</code>了，如果已删除过，则重复，直接<code>return</code></li>
</ul>
<h2 id="check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree">Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree</h2>
<p>Medium(Maybe)</p>
<ul>
<li><a href="https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/532/week-5/3315/">https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/532/week-5/3315/</a></li>
<li>必须从root开始，到leaf结束</li>
<li>两种情况
<ol>
<li>当前节点value != arr[i], return false;</li>
<li>arr到达末尾，树未遍历到leaf, return false;</li>
</ol>
</li>
<li>遍历左右子树，root为根有一棵子树为true则存在序列</li>
</ul>
                    </div>
                    
                    

                    

                    
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
        <span class="block font-bold">上一页</span>
        <a href="/zh/docs/notes/easy/" class="block">Easy</a>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">下一页</span>
        <a href="/zh/docs/notes/hard/" class="block">Hard</a>
        
    </div>
</div>

                    

<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zjoey" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


                </div>
                
                <div class="hidden lg:block lg:w-1/4">
                    
                    <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-secondary-bg pt-16 -mt-16 ">
    <span class="text-lg font-semibold">本页内容</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6  pt-10 -mt-10 border-l ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#3-无重复字符的最长子串">[3] 无重复字符的最长子串</a></li>
    <li><a href="#8-字符串转换整数-atoi">[8] 字符串转换整数 (atoi)</a></li>
    <li><a href="#15-三数之和">[15] 三数之和</a></li>
    <li><a href="#19-删除链表的倒数第n个节点">[19] 删除链表的倒数第N个节点</a></li>
    <li><a href="#31-下一个排列">[31] 下一个排列</a></li>
    <li><a href="#33-搜索旋转排序数组">[33] 搜索旋转排序数组</a></li>
    <li><a href="#36-有效的数独">[36] 有效的数独</a></li>
    <li><a href="#46-全排列">[46] 全排列</a></li>
    <li><a href="#48-旋转图像">[48] 旋转图像</a></li>
    <li><a href="#49--group-anagrams字母异位词分组">[49]  Group Anagrams，字母异位词分组</a></li>
    <li><a href="#55-跳跃游戏">[55] 跳跃游戏</a></li>
    <li><a href="#61-旋转链表">[61] 旋转链表</a></li>
    <li><a href="#62-不同路径">[62] 不同路径</a></li>
    <li><a href="#64-最小路径和">[64] 最小路径和</a></li>
    <li><a href="#78-子集">[78] 子集</a></li>
    <li><a href="#86-分隔链表">[86] 分隔链表</a></li>
    <li><a href="#92-reverse-linked-list-ii">[92] Reverse Linked List II</a></li>
    <li><a href="#93-复原ip地址">[93] 复原IP地址</a></li>
    <li><a href="#94-二叉树的中序遍历">[94] 二叉树的中序遍历</a></li>
    <li><a href="#116-填充每个节点的下一个右侧节点指针">[116] 填充每个节点的下一个右侧节点指针</a></li>
    <li><a href="#124-二叉树中的最大路径和">[124] 二叉树中的最大路径和</a></li>
    <li><a href="#127-单词接龙">[127] 单词接龙</a></li>
    <li><a href="#144-二叉树的前序遍历">[144] 二叉树的前序遍历</a></li>
    <li><a href="#146-lru缓存机制">[146] LRU缓存机制</a></li>
    <li><a href="#179-largest-number">[179] Largest Number</a></li>
    <li><a href="#200-岛屿数量">[200] 岛屿数量</a></li>
    <li><a href="#201-数字范围按位与">[201] 数字范围按位与</a></li>
    <li><a href="#207-课程表">[207] 课程表</a></li>
    <li><a href="#215-数组中的第k个最大元素">[215] 数组中的第K个最大元素</a></li>
    <li><a href="#221-最大正方形">[221] 最大正方形</a></li>
    <li><a href="#238-除自身以外数组的乘积">[238] 除自身以外数组的乘积</a></li>
    <li><a href="#376-摆动序列">[376] 摆动序列</a></li>
    <li><a href="#402-移掉k位数字">[402] 移掉K位数字</a></li>
    <li><a href="#495-teemo-attacking">[495] Teemo Attacking</a></li>
    <li><a href="#503-下一个更大元素-ii">[503] 下一个更大元素 II</a></li>
    <li><a href="#525-连续数组">[525] 连续数组</a></li>
    <li><a href="#540-有序数组中的单一元素">[540] 有序数组中的单一元素</a></li>
    <li><a href="#560-和为k的子数组">[560] 和为K的子数组</a></li>
    <li><a href="#649-dota2-参议院">[649] Dota2 参议院</a></li>
    <li><a href="#659-分割数组为连续子序列">[659] 分割数组为连续子序列</a></li>
    <li><a href="#678-有效的括号字符串">[678] 有效的括号字符串</a></li>
    <li><a href="#714-买卖股票的最佳时机含手续费">[714] 买卖股票的最佳时机含手续费</a></li>
    <li><a href="#738-单调递增的数字">[738] 单调递增的数字</a></li>
    <li><a href="#861-翻转矩阵后的得分">[861] 翻转矩阵后的得分</a></li>
    <li><a href="#901-股票价格跨度">[901] 股票价格跨度</a></li>
    <li><a href="#907-子数组的最小值之和">[907] 子数组的最小值之和</a></li>
    <li><a href="#1008-先序遍历构造二叉树">[1008] 先序遍历构造二叉树</a></li>
    <li><a href="#1094-car-pooling">[1094] Car Pooling</a></li>
    <li><a href="#1143-最长公共子序列">[1143] 最长公共子序列</a></li>
    <li><a href="#first-unique-numer">First Unique Numer</a></li>
    <li><a href="#check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree">Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree</a></li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
                    
                </div>
                
            </div>

        </div>


    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        hljs.initHighlightingOnLoad();
        changeSidebarHeight();
        switchDocToc();
    })
</script>









            </div>
        </div>
        
    </main>
    <footer class="pl-scrollbar">
        <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2020 <a href="https://www.zjoey.com/">z. Joey &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
    </footer>
</body>

</html>