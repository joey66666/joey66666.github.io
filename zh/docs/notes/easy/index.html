<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>Easy | Leetcode-cn 笔记 | 片刻静思</title>
<link rel="stylesheet" href="/css/eureka.min.css">
<script defer src="/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112541018-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-112541018-1');
</script>


<link rel="icon" type="image/png" sizes="32x32" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_2.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_2.png">

<meta name="description"
  content="[1] Two Sum 两数之和 [7] Reverse Int [9] isPalindrome [14] longestCommonPrefix [20] Valid Parentheses，判断对等括号 [26] Remove Duplicated from Sorted Array 删除排序数组中的重复项 [27] Remove Element 移除元素 [28] 实现 strStr() [35] Search Insert Position 搜索插入位置 [38] Count and Say 外观数列 [53] Maximum Subarray [58] 最后一个单词的长度 [66] Plus One [67] 二进制求和 [70] 爬楼梯 [83] 删除排序链表中的重复元素 [88] Merge Sorted Array [100] 相同的树 [101] 对称二叉树 [104] 二叉树的最大深度 [107] 二叉树的层次遍历 II [108] 将有序数组转换为二叉搜索树 [110] 平衡二叉树 [111] 二叉树的最小深度 [112] 路径总和 [118] 杨辉三角 [119] 杨辉三角2 [121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机 [122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II [125] 验证回文串 [136] SingleNumber [141] 环形链表 [155] 最小栈 [160] 相交链表 [167] 两数之和 II - 输入有序数组 [168] Excel表列名称 [169] 多数元素 [171] Excel表列序号 [172] 阶乘后的零 [189] 旋转数组 [190] 颠倒二进制位 [191] 位1的个数 [198] 打家劫舍 [202] Happy Number [203] 移除链表元素 [204] 计数质数 [205] 同构字符串 [206] Reverse Linked List [217] 存在重复元素## [219] 存在重复元素 II [225] 用队列实现栈 [226] 翻转二叉树 [228] 汇总区间 [231] 2的幂 [232] 用栈实现队列 [234] 回文链表 [235] 二叉搜索树的最近公共祖先 [237] 删除链表中的节点 [242] 有效的字母异位词 [257] 二叉树的所有路径 [258] 各位相加 [263] 丑数 [268] 缺失数字 [278] 第一个错误的版本 [283] Move Zeros，0元素移到最后，其他不变 [290] 单词规律 [344] 反转字符串## [350] 两个数组的交集 II [367] 有效的完全平方数 [371] 两整数之和 [383] 赎金信 [387] 字符串中的第一个唯一字符 [389] 找不同 [455] 分发饼干 [674] 最长连续递增序列 [476] 数字的补数 [496] 下一个更大元素 I [509] 斐波那契数 [543] 二叉树的直径 [643] 子数组最大平均数 I [645] 错误的集合 [690] 员工的重要性 [746] 使用最小花费爬楼梯 [766] 托普利茨矩阵 [771] 宝石与石头 [783] 二叉搜索树节点最小距离 [830] 较大分组的位置 [844] 比较含退格的字符串 [852] 山脉数组的峰顶索引 [860] 柠檬水找零 [872] 叶子相似的树 [876] 链表的中间结点 [888] 公平的糖果交换 [938] 二叉搜索树的范围和 [993] 二叉树的堂兄弟节点 [997] 找到小镇的法官 [1018] 可被 5 整除的二进制前缀 [1046] 最后一块石头的重量 [1128] 等价多米诺骨牌对的数量 [1232] 缀点成线 [1266] 访问所有点的最小时间 [1342] 将数字变成 0 的操作次数 [1346] 检查整数及其两倍数是否存在 [1486] 数组异或操作 [1603] 设计停车系统 [1720] 解码异或后的数组 剑指 Offer 53 - II.">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Leetcode 解题笔记",
      "item":"/zh/docs/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Leetcode-cn 笔记",
      "item":"/zh/docs/notes/"},{
      "@type": "ListItem",
      "position": 3 ,
      "name":"Easy",
      "item":"/zh/docs/notes/easy/"}]
}
</script><script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/zh/docs/notes/easy/"
    },
    "headline": "Easy | Leetcode-cn 笔记 | 片刻静思","datePublished": "2020-12-17T22:26:52+08:00",
    "dateModified": "2021-07-08T00:02:27+08:00",
    "wordCount":  2102 ,
    "publisher": {
        "@type": "Person",
        "name": "z. Joey",
        "logo": {
            "@type": "ImageObject",
            "url": "/images/icon.png"
        }
        },
    "description": "[1] Two Sum 两数之和 [7] Reverse Int [9] isPalindrome [14] longestCommonPrefix [20] Valid Parentheses，判断对等括号 [26] Remove Duplicated from Sorted Array 删除排序数组中的重复项 [27] Remove Element 移除元素 [28] 实现 strStr() [35] Search Insert Position 搜索插入位置 [38] Count and Say 外观数列 [53] Maximum Subarray [58] 最后一个单词的长度 [66] Plus One [67] 二进制求和 [70] 爬楼梯 [83] 删除排序链表中的重复元素 [88] Merge Sorted Array [100] 相同的树 [101] 对称二叉树 [104] 二叉树的最大深度 [107] 二叉树的层次遍历 II [108] 将有序数组转换为二叉搜索树 [110] 平衡二叉树 [111] 二叉树的最小深度 [112] 路径总和 [118] 杨辉三角 [119] 杨辉三角2 [121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机 [122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II [125] 验证回文串 [136] SingleNumber [141] 环形链表 [155] 最小栈 [160] 相交链表 [167] 两数之和 II - 输入有序数组 [168] Excel表列名称 [169] 多数元素 [171] Excel表列序号 [172] 阶乘后的零 [189] 旋转数组 [190] 颠倒二进制位 [191] 位1的个数 [198] 打家劫舍 [202] Happy Number [203] 移除链表元素 [204] 计数质数 [205] 同构字符串 [206] Reverse Linked List [217] 存在重复元素## [219] 存在重复元素 II [225] 用队列实现栈 [226] 翻转二叉树 [228] 汇总区间 [231] 2的幂 [232] 用栈实现队列 [234] 回文链表 [235] 二叉搜索树的最近公共祖先 [237] 删除链表中的节点 [242] 有效的字母异位词 [257] 二叉树的所有路径 [258] 各位相加 [263] 丑数 [268] 缺失数字 [278] 第一个错误的版本 [283] Move Zeros，0元素移到最后，其他不变 [290] 单词规律 [344] 反转字符串## [350] 两个数组的交集 II [367] 有效的完全平方数 [371] 两整数之和 [383] 赎金信 [387] 字符串中的第一个唯一字符 [389] 找不同 [455] 分发饼干 [674] 最长连续递增序列 [476] 数字的补数 [496] 下一个更大元素 I [509] 斐波那契数 [543] 二叉树的直径 [643] 子数组最大平均数 I [645] 错误的集合 [690] 员工的重要性 [746] 使用最小花费爬楼梯 [766] 托普利茨矩阵 [771] 宝石与石头 [783] 二叉搜索树节点最小距离 [830] 较大分组的位置 [844] 比较含退格的字符串 [852] 山脉数组的峰顶索引 [860] 柠檬水找零 [872] 叶子相似的树 [876] 链表的中间结点 [888] 公平的糖果交换 [938] 二叉搜索树的范围和 [993] 二叉树的堂兄弟节点 [997] 找到小镇的法官 [1018] 可被 5 整除的二进制前缀 [1046] 最后一块石头的重量 [1128] 等价多米诺骨牌对的数量 [1232] 缀点成线 [1266] 访问所有点的最小时间 [1342] 将数字变成 0 的操作次数 [1346] 检查整数及其两倍数是否存在 [1486] 数组异或操作 [1603] 设计停车系统 [1720] 解码异或后的数组 剑指 Offer 53 - II."
}
</script><meta property="og:title" content="Easy | Leetcode-cn 笔记 | 片刻静思" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/images/icon.png">


<meta property="og:url" content="/zh/docs/notes/easy/" />




<meta property="og:description" content="[1] Two Sum 两数之和 [7] Reverse Int [9] isPalindrome [14] longestCommonPrefix [20] Valid Parentheses，判断对等括号 [26] Remove Duplicated from Sorted Array 删除排序数组中的重复项 [27] Remove Element 移除元素 [28] 实现 strStr() [35] Search Insert Position 搜索插入位置 [38] Count and Say 外观数列 [53] Maximum Subarray [58] 最后一个单词的长度 [66] Plus One [67] 二进制求和 [70] 爬楼梯 [83] 删除排序链表中的重复元素 [88] Merge Sorted Array [100] 相同的树 [101] 对称二叉树 [104] 二叉树的最大深度 [107] 二叉树的层次遍历 II [108] 将有序数组转换为二叉搜索树 [110] 平衡二叉树 [111] 二叉树的最小深度 [112] 路径总和 [118] 杨辉三角 [119] 杨辉三角2 [121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机 [122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II [125] 验证回文串 [136] SingleNumber [141] 环形链表 [155] 最小栈 [160] 相交链表 [167] 两数之和 II - 输入有序数组 [168] Excel表列名称 [169] 多数元素 [171] Excel表列序号 [172] 阶乘后的零 [189] 旋转数组 [190] 颠倒二进制位 [191] 位1的个数 [198] 打家劫舍 [202] Happy Number [203] 移除链表元素 [204] 计数质数 [205] 同构字符串 [206] Reverse Linked List [217] 存在重复元素## [219] 存在重复元素 II [225] 用队列实现栈 [226] 翻转二叉树 [228] 汇总区间 [231] 2的幂 [232] 用栈实现队列 [234] 回文链表 [235] 二叉搜索树的最近公共祖先 [237] 删除链表中的节点 [242] 有效的字母异位词 [257] 二叉树的所有路径 [258] 各位相加 [263] 丑数 [268] 缺失数字 [278] 第一个错误的版本 [283] Move Zeros，0元素移到最后，其他不变 [290] 单词规律 [344] 反转字符串## [350] 两个数组的交集 II [367] 有效的完全平方数 [371] 两整数之和 [383] 赎金信 [387] 字符串中的第一个唯一字符 [389] 找不同 [455] 分发饼干 [674] 最长连续递增序列 [476] 数字的补数 [496] 下一个更大元素 I [509] 斐波那契数 [543] 二叉树的直径 [643] 子数组最大平均数 I [645] 错误的集合 [690] 员工的重要性 [746] 使用最小花费爬楼梯 [766] 托普利茨矩阵 [771] 宝石与石头 [783] 二叉搜索树节点最小距离 [830] 较大分组的位置 [844] 比较含退格的字符串 [852] 山脉数组的峰顶索引 [860] 柠檬水找零 [872] 叶子相似的树 [876] 链表的中间结点 [888] 公平的糖果交换 [938] 二叉搜索树的范围和 [993] 二叉树的堂兄弟节点 [997] 找到小镇的法官 [1018] 可被 5 整除的二进制前缀 [1046] 最后一块石头的重量 [1128] 等价多米诺骨牌对的数量 [1232] 缀点成线 [1266] 访问所有点的最小时间 [1342] 将数字变成 0 的操作次数 [1346] 检查整数及其两倍数是否存在 [1486] 数组异或操作 [1603] 设计停车系统 [1720] 解码异或后的数组 剑指 Offer 53 - II." />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="片刻静思" />






<meta property="article:published_time" content="2020-12-17T22:26:52&#43;08:00" />


<meta property="article:modified_time" content="2021-07-08T00:02:27&#43;08:00" />



<meta property="article:section" content="docs" />




<body class="flex flex-col min-h-screen">
    <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
        <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if ((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) {
        document.getElementsByTagName('html')[0].classList.add('dark')
    } else if (storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap p-4">
    <a href="/zh" class="mr-6 text-primary-text text-xl font-bold">片刻静思</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0" id="current-url"
            currenturl="/zh/docs/notes/easy/">
            <a href="/zh/posts/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">博文</a>
            <a href="/zh/quotation/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">摘录</a>
            <a href="/zh/docs/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">Leetcode-cn</a>
            <a href="/zh/authors/joey"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">关于</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka">Light</span>
                    <span class="px-4 py-1 hover:text-eureka">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka">Auto</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            switchMode('Auto')
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });

    let currenturl = document.getElementById('current-url').getAttribute('currenturl')
        if (currenturl.length > 1) {
            currenturl = currenturl.substr(0, currenturl.length - 1)
        }

        sessionStorage.setItem("mainKey", currenturl)

        let elements = document.getElementsByClassName('main-a');
        for (let i in elements) {
            if (typeof elements[i] === "object") {
                let elementurl = elements[i].getAttribute('href')
                if (elementurl.length > 1 && elementurl.charAt(elementurl.length - 1) == '/') {
                    elementurl = elementurl.substr(0, elementurl.length - 1)
                }
                if (elementurl == sessionStorage.getItem("mainKey")) {
                    elements[i].classList.add('text-eureka')
                } else {
                    elements[i].classList.remove('text-eureka')
                }
            }
        }
</script></div>
    </header>
    <main class="flex-grow pt-16">
        <div class="pl-scrollbar">
            <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="lg:pt-12">
    <div class="flex flex-col md:flex-row bg-secondary-bg rounded">
        <div class="md:w-1/4 lg:w-1/5 border-r">
            <div class="sticky top-16 pt-6">
                




<div id="sidebar-title" class="md:hidden mx-4 px-2 pt-4 pb-2 md:border-b text-tertiary-text md:text-primary-text">
    <span class="font-semibold">目录</span>
    <i class="fas fa-caret-right ml-1"></i>
</div>

<div id="sidebar-toc"
    class="hidden md:block overflow-y-auto mx-6 md:mx-0 pr-6 pt-2 md:max-h-doc-sidebar bg-primary-bg md:bg-transparent">
    <div class="flex flex-wrap ml-4 -mr-2 p-2 bg-secondary-bg md:bg-primary-bg rounded">
        <a class=" hover:text-eureka"
            href="/zh/docs/notes/">Leetcode-cn 笔记</a>
        
        
        


    </div>
    
<ul class="pl-6">
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" text-eureka  hover:text-eureka"
                href="/zh/docs/notes/easy/">Easy</a>
        </div>
        
    </li>
    
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" hover:text-eureka"
                href="/zh/docs/notes/medium/">Medium</a>
        </div>
        
    </li>
    
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" hover:text-eureka"
                href="/zh/docs/notes/hard/">Hard</a>
        </div>
        
    </li>
    
    
</ul>

</div>





            </div>

        </div>
        <div class="w-full md:w-3/4 lg:w-4/5 pb-8 pt-2 md:pt-8">
            <div class="w-full lg:w-3/4 pl-6 ml-0 mr-auto">
                <h1 class="font-bold text-3xl text-primary-text">Easy</h1>
                <div class="flex flex-wrap flex-row items-center my-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2020-12-17</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>10分钟阅读时长</span>
    </div>
    
    

    
</div>
            </div>
            <div class="flex">
                <div class="w-full lg:w-3/4 px-6">
                    
                    
                    <div class="content">
                        <ul>
<li><a href="#1-two-sum-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">[1] Two Sum 两数之和</a></li>
<li><a href="#7-reverse-int">[7] Reverse Int</a></li>
<li><a href="#9-ispalindrome">[9] isPalindrome</a></li>
<li><a href="#14-longestcommonprefix">[14] longestCommonPrefix</a></li>
<li><a href="#20-valid-parentheses%E5%88%A4%E6%96%AD%E5%AF%B9%E7%AD%89%E6%8B%AC%E5%8F%B7">[20] Valid Parentheses，判断对等括号</a></li>
<li><a href="#26-remove-duplicated-from-sorted-array-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">[26] Remove Duplicated from Sorted Array 删除排序数组中的重复项</a></li>
<li><a href="#27-remove-element-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">[27] Remove Element 移除元素</a></li>
<li><a href="#28-%E5%AE%9E%E7%8E%B0-strstr">[28] 实现 strStr()</a></li>
<li><a href="#35-search-insert-position-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE">[35] Search Insert Position 搜索插入位置</a></li>
<li><a href="#38-count-and-say-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97">[38] Count and Say 外观数列</a></li>
<li><a href="#53-maximum-subarray">[53] Maximum Subarray</a></li>
<li><a href="#58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6">[58] 最后一个单词的长度</a></li>
<li><a href="#66-plus-one">[66] Plus One</a></li>
<li><a href="#67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C">[67] 二进制求和</a></li>
<li><a href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF">[70] 爬楼梯</a></li>
<li><a href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">[83] 删除排序链表中的重复元素</a></li>
<li><a href="#88-merge-sorted-array">[88] Merge Sorted Array</a></li>
<li><a href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91">[100] 相同的树</a></li>
<li><a href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">[101] 对称二叉树</a></li>
<li><a href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">[104] 二叉树的最大深度</a></li>
<li><a href="#107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-ii">[107] 二叉树的层次遍历 II</a></li>
<li><a href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">[108] 将有序数组转换为二叉搜索树</a></li>
<li><a href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">[110] 平衡二叉树</a></li>
<li><a href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6">[111] 二叉树的最小深度</a></li>
<li><a href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C">[112] 路径总和</a></li>
<li><a href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92">[118] 杨辉三角</a></li>
<li><a href="#119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922">[119] 杨辉三角2</a></li>
<li><a href="#121-best-time-to-buy-and-sell-stock%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">[121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机</a></li>
<li><a href="#122-best-time-to-buy-and-sell-stock-ii%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii">[122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II</a></li>
<li><a href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2">[125] 验证回文串</a></li>
<li><a href="#136-singlenumber">[136] SingleNumber</a></li>
<li><a href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">[141] 环形链表</a></li>
<li><a href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88">[155] 最小栈</a></li>
<li><a href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8">[160] 相交链表</a></li>
<li><a href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii---%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">[167] 两数之和 II - 输入有序数组</a></li>
<li><a href="#168-excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0">[168] Excel表列名称</a></li>
<li><a href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0">[169] 多数元素</a></li>
<li><a href="#171-excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7">[171] Excel表列序号</a></li>
<li><a href="#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6">[172] 阶乘后的零</a></li>
<li><a href="#189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84">[189] 旋转数组</a></li>
<li><a href="#190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D">[190] 颠倒二进制位</a></li>
<li><a href="#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0">[191] 位1的个数</a></li>
<li><a href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">[198] 打家劫舍</a></li>
<li><a href="#202-happy-number">[202] Happy Number</a></li>
<li><a href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0">[203] 移除链表元素</a></li>
<li><a href="#204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0">[204] 计数质数</a></li>
<li><a href="#205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2">[205] 同构字符串</a></li>
<li><a href="#206-reverse-linked-list">[206] Reverse Linked List</a></li>
<li><a href="#217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">[217] 存在重复元素##</a></li>
<li><a href="#219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii">[219] 存在重复元素 II</a></li>
<li><a href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88">[225] 用队列实现栈</a></li>
<li><a href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">[226] 翻转二叉树</a></li>
<li><a href="#228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4">[228] 汇总区间</a></li>
<li><a href="#231-2%E7%9A%84%E5%B9%82">[231] 2的幂</a></li>
<li><a href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">[232] 用栈实现队列</a></li>
<li><a href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">[234] 回文链表</a></li>
<li><a href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">[235] 二叉搜索树的最近公共祖先</a></li>
<li><a href="#237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9">[237] 删除链表中的节点</a></li>
<li><a href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">[242] 有效的字母异位词</a></li>
<li><a href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84">[257] 二叉树的所有路径</a></li>
<li><a href="#258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0">[258] 各位相加</a></li>
<li><a href="#263-%E4%B8%91%E6%95%B0">[263] 丑数</a></li>
<li><a href="#268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97">[268] 缺失数字</a></li>
<li><a href="#278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC">[278] 第一个错误的版本</a></li>
<li><a href="#283--move-zeros0%E5%85%83%E7%B4%A0%E7%A7%BB%E5%88%B0%E6%9C%80%E5%90%8E%E5%85%B6%E4%BB%96%E4%B8%8D%E5%8F%98">[283]  Move Zeros，0元素移到最后，其他不变</a></li>
<li><a href="#290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B">[290] 单词规律</a></li>
<li><a href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">[344] 反转字符串##</a></li>
<li><a href="#350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-ii">[350] 两个数组的交集 II</a></li>
<li><a href="#367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0">[367] 有效的完全平方数</a></li>
<li><a href="#371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C">[371] 两整数之和</a></li>
<li><a href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1">[383] 赎金信</a></li>
<li><a href="#387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6">[387] 字符串中的第一个唯一字符</a></li>
<li><a href="#389-%E6%89%BE%E4%B8%8D%E5%90%8C">[389] 找不同</a></li>
<li><a href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2">[455] 分发饼干</a></li>
<li><a href="#674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97">[674] 最长连续递增序列</a></li>
<li><a href="#476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0">[476] 数字的补数</a></li>
<li><a href="#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-i">[496] 下一个更大元素 I</a></li>
<li><a href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0">[509] 斐波那契数</a></li>
<li><a href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84">[543] 二叉树的直径</a></li>
<li><a href="#643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-i">[643] 子数组最大平均数 I</a></li>
<li><a href="#645-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88">[645] 错误的集合</a></li>
<li><a href="#690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">[690] 员工的重要性</a></li>
<li><a href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF">[746] 使用最小花费爬楼梯</a></li>
<li><a href="#766-%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5">[766] 托普利茨矩阵</a></li>
<li><a href="#771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4">[771] 宝石与石头</a></li>
<li><a href="#783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB">[783] 二叉搜索树节点最小距离</a></li>
<li><a href="#830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE">[830] 较大分组的位置</a></li>
<li><a href="#844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">[844] 比较含退格的字符串</a></li>
<li><a href="#852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95">[852] 山脉数组的峰顶索引</a></li>
<li><a href="#860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6">[860] 柠檬水找零</a></li>
<li><a href="#872-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91">[872] 叶子相似的树</a></li>
<li><a href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9">[876] 链表的中间结点</a></li>
<li><a href="#888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E4%BA%A4%E6%8D%A2">[888] 公平的糖果交换</a></li>
<li><a href="#938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C">[938] 二叉搜索树的范围和</a></li>
<li><a href="#993-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9">[993] 二叉树的堂兄弟节点</a></li>
<li><a href="#997-%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98">[997] 找到小镇的法官</a></li>
<li><a href="#1018-%E5%8F%AF%E8%A2%AB-5-%E6%95%B4%E9%99%A4%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%89%8D%E7%BC%80">[1018] 可被 5 整除的二进制前缀</a></li>
<li><a href="#1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F">[1046] 最后一块石头的重量</a></li>
<li><a href="#1128-%E7%AD%89%E4%BB%B7%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F">[1128] 等价多米诺骨牌对的数量</a></li>
<li><a href="#1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF">[1232] 缀点成线</a></li>
<li><a href="#1266-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4">[1266] 访问所有点的最小时间</a></li>
<li><a href="#1342-%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%90-0-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0">[1342] 将数字变成 0 的操作次数</a></li>
<li><a href="#1346-%E6%A3%80%E6%9F%A5%E6%95%B4%E6%95%B0%E5%8F%8A%E5%85%B6%E4%B8%A4%E5%80%8D%E6%95%B0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8">[1346] 检查整数及其两倍数是否存在</a></li>
<li><a href="#1486-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C">[1486] 数组异或操作</a></li>
<li><a href="#1603-%E8%AE%BE%E8%AE%A1%E5%81%9C%E8%BD%A6%E7%B3%BB%E7%BB%9F">[1603] 设计停车系统</a></li>
<li><a href="#1720-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84">[1720] 解码异或后的数组</a></li>
<li><a href="#%E5%89%91%E6%8C%87-offer-53---ii-0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></li>
</ul>
<h2 id="1-two-sum-两数之和">[1] Two Sum 两数之和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></li>
</ul>
<ol>
<li>Solution1, Hash, Time: O(n), Space: O(n), Runtime: 50%
<ul>
<li>遍历<code>nums</code>，放入<code>num</code>, 判断 <code>target - num</code> 在不在 <code>Hash</code> 中</li>
</ul>
</li>
</ol>
<h2 id="7-reverse-int">[7] Reverse Int</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/reverse-integer/">https://leetcode-cn.com/problems/reverse-integer/</a></li>
</ul>
<ol>
<li>Solution1, java
<ul>
<li><code>n = n * 10 + x % 10</code></li>
<li>通过<code>long n == int n</code>判断是否溢出</li>
</ul>
</li>
<li>Solution1, 模拟运算, Time: O(n), Space: O(1), Runtime: 77%
<ul>
<li><code>res = res * 10 + x % 10</code></li>
<li><code>x //= 10</code></li>
<li>在 <code>python</code> 里 <code>//=</code> 会对负数向下取整，所以正负数分情况</li>
<li><code>python3</code> 默认使用长整型，不存在溢出，通过 <code>-(2 ** 31) &lt;= res &lt;= 2 ** 31 - 1</code>判断溢出</li>
</ul>
</li>
</ol>
<h2 id="9-ispalindrome">[9] isPalindrome</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/palindrome-number/">https://leetcode-cn.com/problems/palindrome-number/</a></li>
</ul>
<h2 id="14-longestcommonprefix">[14] longestCommonPrefix</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-common-prefix">https://leetcode-cn.com/problems/longest-common-prefix</a></li>
</ul>
<ol>
<li>暴力，先内循环选定数组第一个元素，再外循环与数组内其他元素比较</li>
<li>从后往前裁剪至符合，若不符合则裁剪至空</li>
</ol>
<h2 id="20-valid-parentheses判断对等括号">[20] Valid Parentheses，判断对等括号</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a></li>
</ul>
<ol>
<li>Solution1, 栈，Time: O(n), Space: O(n), Runtime: 86%
<ul>
<li>简单栈，左边括号放进去，右边括号pop出来并匹配</li>
<li>注意只有一个括号的边界情况</li>
</ul>
</li>
<li>Solution2, 高级写法, TIme: O(n), Sapce: O(n), Runtime: 17%</li>
</ol>
<ul>
<li>根据 now 指向来 push 对应的括号，判断 pop 是否==对应</li>
</ul>
<h2 id="26-remove-duplicated-from-sorted-array-删除排序数组中的重复项">[26] Remove Duplicated from Sorted Array 删除排序数组中的重复项</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a></li>
</ul>
<ol>
<li>Solution1, 双指针, Time: O(n), Sapce: O(1), Runtime: 97%
<ul>
<li>外循环作右指针，设置一个变量作为左指针，当左右不同时，右赋值给左，左移动一位</li>
</ul>
</li>
</ol>
<h2 id="27-remove-element-移除元素">[27] Remove Element 移除元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a></li>
</ul>
<ol>
<li>Solution1, 排序后双指针遍历，移动到左和右区间，继续遍历，右覆盖左, Time: O(nlogn), Space: O(1), Runtime: 60%</li>
<li>Solution2, 优化1，用自带的nums.index()先拿到左指针位置, Time: O(n), Space: O(1), Runtime: 94%</li>
<li>Solution3, 双指针从左开始遍历，赋值非 val 的数值, Time: O(n), Space: O(1), Runtime: 60%
<ul>
<li>右指针走，if nums[right] != val, nums[left] = nums[right]</li>
</ul>
</li>
<li>Solution4, 双指针从左右往中间逼近，不用考虑顺序，所以可以把末尾那段逆向赋值到val段，Time: O(n), Space: O(1), Runtime: 60%</li>
</ol>
<h2 id="28-实现-strstr">[28] 实现 strStr()</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/implement-strstr/description/">https://leetcode-cn.com/problems/implement-strstr/description/</a></li>
</ul>
<ol>
<li>Solution1, 暴力，Time: O(n * m), Space: O(1), Runtime: 39%
<ul>
<li>每个 haystack 按字符匹配 needle, 不符合立即停止该字串匹配,</li>
</ul>
</li>
<li>好的解法：KMP，暂时不看</li>
</ol>
<h2 id="35-search-insert-position-搜索插入位置">[35] Search Insert Position 搜索插入位置</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/search-insert-position">https://leetcode-cn.com/problems/search-insert-position</a></li>
<li>once &lt; or = 则返回，为插入位置</li>
<li>搜索不到返回 nums.length 即插入最大值位置</li>
<li>太巧妙了！</li>
</ul>
<h2 id="38-count-and-say-外观数列">[38] Count and Say 外观数列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-and-say/description/">https://leetcode-cn.com/problems/count-and-say/description/</a></li>
<li>这题挺有意思</li>
</ul>
<h2 id="53-maximum-subarray">[53] Maximum Subarray</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a></li>
</ul>
<ol>
<li>Solution1: DP, Time: O(n), Space: O(n), Runtime: 93%
<ul>
<li>初始状态:<code>dp[0] = nums[0]</code></li>
<li>状态转移:<code>dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])</code>，若之前数组<code>sum &lt; 0</code>，丢弃之前数组，新数组只有<code>nums[i]</code>，否则将<code>nums[i]</code>加入新数组，继续遍历</li>
<li>遍历过程中存在遍历到负值，不加，维持之前数组的可能。所以另需变量保存遍历过程遇到的数组之和最大值，即结果</li>
</ul>
</li>
</ol>
<h2 id="58-最后一个单词的长度">[58] 最后一个单词的长度</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/length-of-last-word/description/">https://leetcode-cn.com/problems/length-of-last-word/description/</a></li>
</ul>
<h2 id="66-plus-one">[66] Plus One</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></li>
<li>判断是否进位</li>
</ul>
<h2 id="67-二进制求和">[67] 二进制求和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/add-binary/description/">https://leetcode-cn.com/problems/add-binary/description/</a></li>
<li>当前位 = sum % 2，进位 = sum / 2，if (进位 != 0) { append 进位 }</li>
</ul>
<h2 id="70-爬楼梯">[70] 爬楼梯</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/climbing-stairs/description/">https://leetcode-cn.com/problems/climbing-stairs/description/</a></li>
<li>斐波那契数列找规律 ( res[i] = res[i-1]  + res[i-2] )</li>
<li><strong>直接递归 ( return res[i-1] + res[i-2] ) 会超时</strong></li>
</ul>
<h2 id="83-删除排序链表中的重复元素">[83] 删除排序链表中的重复元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/</a></li>
</ul>
<ol>
<li>Solution1, 一次遍历, Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li>注意边界，判断<code>null</code></li>
</ul>
</li>
</ol>
<h2 id="88-merge-sorted-array">[88] Merge Sorted Array</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a></li>
<li>排序好的数组，从后往前插入</li>
<li>比大小，大于从尾插，小于则swap</li>
<li>剩下直接插在头</li>
</ul>
<h2 id="100-相同的树">[100] 相同的树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/same-tree/description/">https://leetcode-cn.com/problems/same-tree/description/</a></li>
<li>递归写法</li>
</ul>
<h2 id="101-对称二叉树">[101] 对称二叉树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/symmetric-tree/description/">https://leetcode-cn.com/problems/symmetric-tree/description/</a></li>
<li>从外往内包裹着比较</li>
<li>不要想太复杂</li>
</ul>
<h2 id="104-二叉树的最大深度">[104] 二叉树的最大深度</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/</a></li>
</ul>
<h2 id="107-二叉树的层次遍历-ii">[107] 二叉树的层次遍历 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/description/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/description/</a></li>
<li>自顶向下存储，<code>reverse</code>后输出</li>
<li>完全遍历下一层：</li>
</ul>
<pre><code class="language-java">for ( TreeNode node : next_level ){
    vals.add( node.val );
}
</code></pre>
<h2 id="108-将有序数组转换为二叉搜索树">[108] 将有序数组转换为二叉搜索树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/</a></li>
<li>二叉平衡树定义：<code>left.val &lt; root.val &amp;&amp; right.val &gt; root.val</code></li>
<li>取中间值<code>(mid = (start + end) / 2)</code>为root，左边<code>nums[start, mid - 1]</code>为左子树，右边<code>nums[mid + 1, end]</code>为右子树</li>
</ul>
<h2 id="110-平衡二叉树">[110] 平衡二叉树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/description/">https://leetcode-cn.com/problems/balanced-binary-tree/description/</a></li>
<li>中间使用<code>-1</code>判断<code>false</code>，若<code>-1</code>则再次直接<code>return -1</code></li>
</ul>
<h2 id="111-二叉树的最小深度">[111] 二叉树的最小深度</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/</a></li>
<li>与 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">[104] 二叉树的最大深度 </a> 做法类似，https://github.com/joey66666/Algorithms/issues/2#issuecomment-612340952</li>
<li>注意区分<code>root.left != null, root.right != null</code> 的情况，分开讨论</li>
</ul>
<h2 id="112-路径总和">[112] 路径总和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/path-sum/description/">https://leetcode-cn.com/problems/path-sum/description/</a></li>
<li>到叶子节点判断 <code>sum - root.val == 0</code>，没到叶子节点 <code>sum - root.val</code>继续递归 <code>root.left</code>或<code>root.right</code></li>
</ul>
<h2 id="118-杨辉三角">[118] 杨辉三角</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/pascals-triangle/">https://leetcode-cn.com/problems/pascals-triangle/</a></li>
<li>[i][0] = 1</li>
<li>[i][j] = [i-1][j-1] + [i-1][j]</li>
</ul>
<h2 id="119-杨辉三角2">[119] 杨辉三角2</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">https://leetcode-cn.com/problems/pascals-triangle-ii/</a></li>
<li>设置中间变量保存上一层，与当前层迭代更新</li>
</ul>
<h2 id="121-best-time-to-buy-and-sell-stock买卖股票的最佳时机">[121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/</a></li>
<li>典型DP，把握初始状态（ prices[0] ）和状态转移条件 ( now &lt; start &amp; now_profit &gt; last_profit )</li>
</ul>
<h2 id="122-best-time-to-buy-and-sell-stock-ii买卖股票的最佳时机-ii">[122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/</a></li>
<li><strong>包含当天买入，当天卖出的情况</strong></li>
<li>贪心体现在追求当下利润最大 ( now_profit &gt; 0 )</li>
</ul>
<h2 id="125-验证回文串">[125] 验证回文串</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-palindrome/description/">https://leetcode-cn.com/problems/valid-palindrome/description/</a></li>
</ul>
<h2 id="136-singlenumber">[136] SingleNumber</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></li>
</ul>
<ol>
<li>Solution1 HashSet, if ( ! s.add ( x ))  s.remove( x );</li>
<li>Solution2 异或运用尤其巧妙，0 ^ int = int，int ^ int = 0;</li>
</ol>
<h2 id="141-环形链表">[141] 环形链表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle/description/">https://leetcode-cn.com/problems/linked-list-cycle/description/</a></li>
</ul>
<ol>
<li>Solution1, 快慢指针，Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li>循环条件: <code>fast != null &amp; fast.next != null</code></li>
<li>如果用 <code>slow</code> 判断，会出现无环的 case 中 <code>fast</code> 跑到 <code>null</code> 的情况</li>
</ul>
</li>
</ol>
<h2 id="155-最小栈">[155] 最小栈</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/min-stack/description/">https://leetcode-cn.com/problems/min-stack/description/</a></li>
<li>用另一个栈保存最小元素，栈顶最小（不是最小push栈顶本身，保证两个栈大小相等）</li>
</ul>
<h2 id="160-相交链表">[160] 相交链表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/</a></li>
<li>计算长度差，长的先走到两边平齐，再一起走，相交则return，走到头不相交return null</li>
</ul>
<h2 id="167-两数之和-ii---输入有序数组">[167] 两数之和 II - 输入有序数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/</a></li>
<li>头尾指针，头尾和 &gt; target, 尾指针左移；头尾和 &lt; target, 头指针右移</li>
<li>Time: O(n)</li>
</ul>
<h2 id="168-excel表列名称">[168] Excel表列名称</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/description/">https://leetcode-cn.com/problems/excel-sheet-column-title/description/</a></li>
<li>思路：取余到底，转换成字母，再反向输出</li>
<li>n直接除以26会出错，如<code>52/26=2···0</code>，但在Excel用实际<code>AZ</code>表示，所以先<code>n -= 1</code>。深层原因即计算机以0为第一位，Excel以1为第一位</li>
<li><code>StringBuilder.append()</code>比<code>String += </code>速度快很多</li>
</ul>
<h2 id="169-多数元素">[169] 多数元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/majority-element/description/">https://leetcode-cn.com/problems/majority-element/description/</a></li>
</ul>
<ol>
<li>Solution1: HashMap
<ul>
<li>HashMap，过程中 <code>if hm.get(nums[i]) &gt; nums.length /2</code>则return</li>
<li>Runtime: 38%</li>
<li>Time: O(n), Space: O(n)</li>
</ul>
</li>
<li>Solution2: 摩尔投票法
<ul>
<li>假设 nums[0] 为最多元素，遍历，相同 + 1，不同 - 1</li>
<li>若归零，则前面其他和本身数量相等，对冲抵消，指针当下指向另一个数，换成另一个数，对后面继续遍历比较</li>
<li>Runtime: 99%</li>
<li>Time: O(n), Space: O(1)</li>
</ul>
</li>
</ol>
<h2 id="171-excel表列序号">[171] Excel表列序号</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/description/">https://leetcode-cn.com/problems/excel-sheet-column-number/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/description/">[168] Excel表列名称</a>的反面题</li>
<li>等同 26 -&gt; 10 进制转换</li>
</ul>
<h2 id="172-阶乘后的零">[172] 阶乘后的零</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/">https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/</a></li>
<li>0 的个数，即 10 ^ 个数</li>
<li>10 = 5 * 2</li>
<li>2 的个数易得到，所以10的个数 = 5的个数</li>
<li>如15！中有15，10，5，结果为3</li>
</ul>
<h2 id="189-旋转数组">[189] 旋转数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/rotate-array/description/">https://leetcode-cn.com/problems/rotate-array/description/</a></li>
<li>Solution2, 三次翻转，第一次数组倒序，第二次以k为分界线前后子数组分别倒序</li>
<li>比如12345经过翻转就变成了54321，这样已经做到了把前面的数字放到后面去，但是还没有完全达到要求，只需要把12放在后面去，目标数组就是34512。与54321对比发现我们就只需要在把分界线前后数组再进行翻转一次就可得到目标数组了</li>
<li>Time:O(n) //O(2n)</li>
</ul>
<h2 id="190-颠倒二进制位">[190] 颠倒二进制位</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/reverse-bits/description/">https://leetcode-cn.com/problems/reverse-bits/description/</a></li>
</ul>
<ol>
<li>Solution1, 循环按位运算, Time: O(1), Space: O(1), Runtime: 96%
<ul>
<li>思路：把n最右边一位取出来，res左移一位后加到res上，循环移动32次</li>
</ul>
<pre><code>res = res * 2 + n % 2
n /= 2
</code></pre>
<ul>
<li>以上运算，有符号数下不能用，因为使用补码表示</li>
<li>应使用位操作实现：<code>n &amp; 1</code>来取最后一位</li>
</ul>
<pre><code>res = (res &lt;&lt; 1) | (n &amp; 1)
n &gt;&gt;= 1
</code></pre>
</li>
</ol>
<h2 id="191-位1的个数">[191] 位1的个数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-of-1-bits/description/">https://leetcode-cn.com/problems/number-of-1-bits/description/</a></li>
</ul>
<ol>
<li>Solution1，按位与, Time: O(n), Space: O(1), Runtime: 95%</li>
<li>Solution2, 按位与优化, Time: O(logn), Space: O(1), Runtime: 95%
<ul>
<li>n &amp; (n−1) = 把 n 的二进制位中的最低位的 1 变为 0 之后的结果</li>
<li>如：6 &amp; (6-1) = 4, 6 = (110)2, 4 = (100)2, 运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0 之后的结果</li>
</ul>
</li>
</ol>
<h2 id="198-打家劫舍">[198] 打家劫舍</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/house-robber/description/">https://leetcode-cn.com/problems/house-robber/description/</a></li>
<li>维护一个一位数组 dp，其中 dp[i] 表示 [0, i] 区间可以抢夺的最大值，对当前i来说，有抢和不抢两种互斥的选择。</li>
<li>不抢：dp[i-1]（等价于去掉 nums[i] 只抢 [0, i-1] 区间最大值）</li>
<li>抢：dp[i-2] + nums[i]（等价于去掉 nums[i-1]）</li>
<li>比如 nums为{3, 2, 1, 5}，首先 dp[0]=3 , dp[1]，由于3比2大，所以抢第一个房子的3，当前房子的2不抢，则dp[1]=3。dp[2]由于不能抢相邻的，所以可以用再前面的一个的 dp 值加上当前的房间值，和当前房间的前面一个 dp 值比较，取较大值当做当前 dp 值</li>
<li>状态转移方程 dp[i] = max(num[i] + dp[i - 2], dp[i - 1]),</li>
<li>需要初始化 dp[0] 和 dp[1]，dp[0] 为 num[0]，dp[1] 为 max(num[0], num[1])</li>
</ul>
<h2 id="202-happy-number">[202] Happy Number</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/happy-number">https://leetcode-cn.com/problems/happy-number</a></li>
</ul>
<h2 id="203-移除链表元素">[203] 移除链表元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/description/">https://leetcode-cn.com/problems/remove-linked-list-elements/description/</a></li>
<li>在<code>head</code>前添加头节点(sentinel, dummyHead)</li>
<li>双指针遍历删除</li>
</ul>
<h2 id="204-计数质数">[204] 计数质数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-primes/description/">https://leetcode-cn.com/problems/count-primes/description/</a></li>
<li>质数：只有1和它本身两个因数的自然数（1不是质数）</li>
<li>从boolean[n]数组中，2开始反向去除所有的非质数(2的倍数，3的倍数，4的倍数&hellip;)，质数false，非质数true</li>
<li>遍历过程使用count记录true的个数</li>
</ul>
<h2 id="205-同构字符串">[205] 同构字符串</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/isomorphic-strings/description/">https://leetcode-cn.com/problems/isomorphic-strings/description/</a></li>
</ul>
<ol>
<li>Solution1，HashMap
<ul>
<li>HashMap&lt;Character, Character&gt;存放 s 和 t 的字符映射</li>
<li>遍历，如果遍历到相同的字符hm.get()不同则return false</li>
<li>需要对s和t都要遍历</li>
<li>如&quot;ab&quot;,&ldquo;aa&quot;的test case第一次遍历得到[&lsquo;a&rsquo;,&lsquo;a&rsquo;],[&lsquo;b&rsquo;,&lsquo;a&rsquo;], 第二次[&lsquo;a&rsquo;,&lsquo;a&rsquo;],[&lsquo;a&rsquo;,&lsquo;b&rsquo;] return false</li>
<li>Runtime: 64%</li>
</ul>
</li>
<li>Solution2，HashMap使用Obejct[]数组重写
<ul>
<li>字符ASCII码的存放index，值对应HashMap的key，val</li>
<li>Runtime: 76%</li>
</ul>
</li>
</ol>
<h2 id="206-reverse-linked-list">[206] Reverse Linked List</h2>
<ul>
<li><a href="https://leetcode.com/problems/reverse-linked-list/">https://leetcode.com/problems/reverse-linked-list/</a></li>
</ul>
<h2 id="217-存在重复元素">[217] 存在重复元素##</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/contains-duplicate/description/">https://leetcode-cn.com/problems/contains-duplicate/description/</a></li>
</ul>
<ol>
<li>Solution1, 简单HashMap/ HashSet, Time: 48%/ 55%</li>
<li>Solution2, HashSet比较长度, Time: 70%
<ul>
<li>HashSet特点：无序；不存储重复元素；没有get()，只能iterator访问</li>
<li>遍历一遍存入HashSet，<code>HashSet.size() &lt; nums.length() ? true : false </code></li>
</ul>
</li>
<li>内置流，比较<code>return Arrays.stream(nums).distinct().count() &lt; nums.length</code>，Time: 55%</li>
<li>排序后比较<code>nums[i] == nums[i - 1]</code>, Time: 99%</li>
</ol>
<h2 id="219-存在重复元素-ii">[219] 存在重复元素 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/description/">https://leetcode-cn.com/problems/contains-duplicate-ii/description/</a></li>
<li>HashMap存Index，每次比较，达条件return true，否则更新Index</li>
</ul>
<h2 id="225-用队列实现栈">[225] 用队列实现栈</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/description/">https://leetcode-cn.com/problems/implement-stack-using-queues/description/</a></li>
<li>双队列实现，a：临时队列，b：总队列</li>
<li>队列a存当前push的数，队列b存之前处理完的完整栈</li>
<li>当前push的存到a的头，把b的每一个add到a的尾</li>
<li>核心：每次完成add后交换a和b，保证a始终为空</li>
</ul>
<h2 id="226-翻转二叉树">[226] 翻转二叉树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/invert-binary-tree/description/">https://leetcode-cn.com/problems/invert-binary-tree/description/</a></li>
<li>递归调换，先进入子树调换完，再调换root.left, root.right</li>
</ul>
<h2 id="228-汇总区间">[228] 汇总区间</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/summary-ranges/description/">https://leetcode-cn.com/problems/summary-ranges/description/</a></li>
</ul>
<ol>
<li>Solution1, 双指针, Time: O(n), Space: O(1), Runtime: 82%
<ul>
<li>左右指针，判断遍历到的数和后一个数的差值是否为1，不是则可构成区间</li>
</ul>
</li>
</ol>
<h2 id="231-2的幂">[231] 2的幂</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/power-of-two/description/">https://leetcode-cn.com/problems/power-of-two/description/</a></li>
<li>2的倍数二进制第一位为1，后面均为0，取最高位异或本身</li>
<li>处理 <code>n &lt;= 0</code>的情况</li>
<li><code>return (Integer.highestOneBit(n) ^ n) == 0</code> Runtime: 23%</li>
<li><code>return (Integer.highestOneBit(n) ^ n) == 0 ? true : false</code> Runtime: 100%</li>
</ul>
<h2 id="232-用栈实现队列">[232] 用栈实现队列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/description/">https://leetcode-cn.com/problems/implement-queue-using-stacks/description/</a></li>
</ul>
<ol>
<li>Solution1, 双栈实现, Time: O(1), Space: O(n), Runtime: 98%
<ul>
<li>双栈<code>in</code>和<code>out</code></li>
<li>Push: <code>in.push()</code></li>
<li>Pop: 若<code>out</code>不为空则<code>out.pop()</code>，若<code>out</code>空则<code>out.push(in.pop())</code>转移所有<code>in</code>元素，再<code>out.pop()</code></li>
</ul>
</li>
</ol>
<h2 id="234-回文链表">[234] 回文链表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/palindrome-linked-list/description/">https://leetcode-cn.com/problems/palindrome-linked-list/description/</a></li>
<li>Time: O(n), Space: O(1)</li>
<li>
<ol>
<li>快指针指到头时慢指针指到中间</li>
<li>反向慢指针到结尾之间的节点</li>
<li>逐个比较前一半和反向过的后一半</li>
</ol>
</li>
</ul>
<h2 id="235-二叉搜索树的最近公共祖先">[235] 二叉搜索树的最近公共祖先</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/</a></li>
</ul>
<ol>
<li>Solution1, 一次遍历, Time: O(n), Space: O(1), Runtime: 53%
<ul>
<li>利用二叉搜索树特性：left.val &lt; root.val &lt; right.val</li>
<li>若p、q &lt; root 则一定在左子树中，若p、q &gt; root 则一定在右子树中，否则return root</li>
</ul>
</li>
</ol>
<h2 id="237-删除链表中的节点">[237] 删除链表中的节点</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/description/">https://leetcode-cn.com/problems/delete-node-in-a-linked-list/description/</a></li>
<li>next.val赋值给node,删除下一个node</li>
</ul>
<h2 id="242-有效的字母异位词">[242] 有效的字母异位词</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-anagram/description/">https://leetcode-cn.com/problems/valid-anagram/description/</a></li>
<li>三种解法：HashMap, Alphabet Array, Arrays.toCharArray() -&gt; Sort()</li>
</ul>
<h2 id="257-二叉树的所有路径">[257] 二叉树的所有路径</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-paths/description/">https://leetcode-cn.com/problems/binary-tree-paths/description/</a></li>
<li>traverse()函数，递归深入</li>
</ul>
<h2 id="258-各位相加">[258] 各位相加</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/add-digits/description/">https://leetcode-cn.com/problems/add-digits/description/</a></li>
<li>找规律</li>
</ul>
<h2 id="263-丑数">[263] 丑数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/ugly-number/description/">https://leetcode-cn.com/problems/ugly-number/description/</a></li>
</ul>
<ol>
<li>Solution1, 暴力, 除到底，判断是否有余数, Time: O(logn), Space: O(1), Runtime: 50%</li>
</ol>
<h2 id="268-缺失数字">[268] 缺失数字</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/missing-number/description/">https://leetcode-cn.com/problems/missing-number/description/</a></li>
<li>1 - n 相加减去nums中的和</li>
</ul>
<h2 id="278-第一个错误的版本">[278] 第一个错误的版本</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/first-bad-version/description/">https://leetcode-cn.com/problems/first-bad-version/description/</a></li>
<li>简单二分，注意循环条件</li>
</ul>
<h2 id="283--move-zeros0元素移到最后其他不变">[283]  Move Zeros，0元素移到最后，其他不变</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/move-zeroes">https://leetcode-cn.com/problems/move-zeroes</a></li>
</ul>
<ol>
<li>S1，快慢双指针遍历</li>
<li>S2，单指针，非0往前移，统计0个数n；后n个置0</li>
</ol>
<h2 id="290-单词规律">[290] 单词规律</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/word-pattern/description/">https://leetcode-cn.com/problems/word-pattern/description/</a></li>
</ul>
<ol>
<li>Solution
<ul>
<li>简单HashMap，注意区分a和b的value不能相等，通过加入时判断<code>hm.containsValue</code></li>
<li>使用<code>Object.equals()</code>取代 <code>==</code> 更健壮</li>
</ul>
</li>
</ol>
<h2 id="344-反转字符串">[344] 反转字符串##</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/reverse-string/description/">https://leetcode-cn.com/problems/reverse-string/description/</a></li>
<li>循环到中间</li>
</ul>
<h2 id="350-两个数组的交集-ii">[350] 两个数组的交集 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/description/">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/description/</a></li>
<li>HashMap两次遍历两个数组</li>
</ul>
<h2 id="367-有效的完全平方数">[367] 有效的完全平方数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-perfect-square/description/">https://leetcode-cn.com/problems/valid-perfect-square/description/</a></li>
<li>从<code>left = 0, right = num</code>开始二分</li>
</ul>
<pre><code class="language-java">long mid = left + (right - left) / 2
long t = mid * mid
if(t == num) return true;
else if(t &lt; num) left = mid + 1;
else right = mid - 1; 
</code></pre>
<ul>
<li>注意要用<code>long</code>数据类型</li>
</ul>
<h2 id="371-两整数之和">[371] 两整数之和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/sum-of-two-integers/description/">https://leetcode-cn.com/problems/sum-of-two-integers/description/</a></li>
</ul>
<ol>
<li>Slution1, 位运算，Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li>模仿计组加法过程</li>
<li><code>a + b = 有进位 + 无进位</code>循环</li>
<li><code>有进位 = a &amp; b/ a &amp; b 再位移</code></li>
<li><code>无进位 = a ^ b</code></li>
<li>把 <code>b</code> 加到 <code>a</code> 上，循环直到 <code>b</code> 为 <code>0</code></li>
</ul>
</li>
</ol>
<h2 id="383-赎金信">[383] 赎金信</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/ransom-note/description/">https://leetcode-cn.com/problems/ransom-note/description/</a></li>
<li><code>int[26]</code>数组遍历<code>magzine</code>统计26个字母使用次数，再遍历<code>ransomNote</code>, <code>if 对应字母 &lt;= 0</code>则return</li>
</ul>
<h2 id="387-字符串中的第一个唯一字符">[387] 字符串中的第一个唯一字符</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/description/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/description/</a></li>
</ul>
<ol>
<li>Solution1， HashMap计次数，遍历两次String
<ul>
<li>Runtime: 30%</li>
<li>Time: O(n) //2n</li>
</ul>
</li>
<li>字母表数组计数，原理&amp;Time同HashMap
<ul>
<li>Runtime: 86%</li>
</ul>
</li>
</ol>
<h2 id="389-找不同">[389] 找不同</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/find-the-difference/description/">https://leetcode-cn.com/problems/find-the-difference/description/</a></li>
</ul>
<ol>
<li>Solution1: Time: O(n), Runtime: 100%, Meomory: 51%
<ul>
<li><code>char[] alphabet</code>字母表，跑一遍s, +=1，跑一遍t, -=1，再遍历找到-1的character</li>
</ul>
</li>
<li>Solution2: Time: O(n), Runtime: 100%, Meomory: 91%
<ul>
<li>位操作，按位异或，与自身异或为零</li>
</ul>
</li>
</ol>
<h2 id="455-分发饼干">[455] 分发饼干</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/assign-cookies/description/">https://leetcode-cn.com/problems/assign-cookies/description/</a></li>
</ul>
<ol>
<li>Solution1: 排序 + 贪心
<ul>
<li>Time: O(nlogn + mlogm), Space: O(logn + logm), Runtime: 89%</li>
<li>尽量使用最小的饼干满足胃口最小的孩子</li>
<li>先排序，再同步遍历两个数组，若当前饼干能满足当前孩子，则均向右移动一个，否则向右移动饼干</li>
<li>优化：
<ol>
<li>不能满足该孩子胃口的情况下跳过不符合条件<code>s[index] &lt; g[child]</code>的饼干（Runtime未得到优化）</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="674-最长连续递增序列">[674] 最长连续递增序列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/description/">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/description/</a></li>
</ul>
<ol>
<li>Solution1, 遍历, Time: O(n), Space: O(1), Runtime: 46%</li>
</ol>
<h2 id="476-数字的补数">[476] 数字的补数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-complement/description/">https://leetcode-cn.com/problems/number-complement/description/</a></li>
<li>直接 ~ 按位取反，前缀的0也会被取反。</li>
<li>所以用 ^ 异或，直接<code>^1</code>前面的位数也会异或，用与<code>num</code>相同位数的数异或</li>
<li>如：101 ^ 111 = 010。怎么得到111？考虑111 + 1 = 1000，而1000又是 最小的 大于101的 只有一位是1 的二进制数。</li>
<li>解决方法：
<ol>
<li>找到最小的大于原数字的二进制值仅有一位为1的数；</li>
<li>将此数减1；</li>
<li>与原数字按位求异或。</li>
</ol>
</li>
<li><code>Integer.highestOneBit(num)</code>：拿到num最高位，后面补0，如 101 返回 100</li>
</ul>
<h2 id="496-下一个更大元素-i">[496] 下一个更大元素 I</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-i/description/">https://leetcode-cn.com/problems/next-greater-element-i/description/</a></li>
<li>HashMap 简单解法</li>
</ul>
<h2 id="509-斐波那契数">[509] 斐波那契数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/fibonacci-number/description/">https://leetcode-cn.com/problems/fibonacci-number/description/</a></li>
</ul>
<ol>
<li>Solution1: 经典DP, Time: O(n), Space: O(n), Runtime: 100%
<ul>
<li>按<code>F(n) = F(n - 1) + F(n - 2)</code>构建<code>dp</code>数组</li>
</ul>
</li>
<li>Solution1: 优化DP, Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li>结果只与三个数有关，使用<code>i, j, k</code>三个变量表示计算结果，迭代，<code>Space</code>优化到<code>O(1)</code></li>
</ul>
</li>
</ol>
<h2 id="543-二叉树的直径">[543] 二叉树的直径</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/description/">https://leetcode-cn.com/problems/diameter-of-binary-tree/description/</a></li>
<li><strong>depth = Math.max( depth, left_depth + right_depth )</strong></li>
<li><strong>向上一层 return 1 + Math.max( left_depth, right_depth )</strong></li>
</ul>
<h2 id="643-子数组最大平均数-i">[643] 子数组最大平均数 I</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/description/">https://leetcode-cn.com/problems/maximum-average-subarray-i/description/</a></li>
</ul>
<ol>
<li>Solution1, Sliding Window, Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li>固定长度的 <code>window</code>，使用 <code>int count</code> 取代 <code>int[] window</code>，每次移动吐出左边的 <code>num</code>，吞下右边的 <code>num</code>，移动过程中 <code>int count</code> 取代<code>double</code>，加速处理，最后返回前除以 <code>k</code></li>
</ul>
</li>
</ol>
<h2 id="645-错误的集合">[645] 错误的集合</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/set-mismatch/description/">https://leetcode-cn.com/problems/set-mismatch/description/</a></li>
</ul>
<ol>
<li>Solution1, 数组模拟Hash, Time: O(n), Space: O(n), Runtime: 55%
<ul>
<li>遍历，找到重复的元素，放入res，再找[1,n]中未出现过的元素，放入res</li>
</ul>
</li>
</ol>
<h2 id="690-员工的重要性">[690] 员工的重要性</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/employee-importance/description/">https://leetcode-cn.com/problems/employee-importance/description/</a></li>
</ul>
<ol>
<li>Solution1, BFS, Time: O(n), Space: O(m), m 为员工和下属的总数量, Runtime: 96%</li>
</ol>
<h2 id="746-使用最小花费爬楼梯">[746] 使用最小花费爬楼梯</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/">https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/</a></li>
</ul>
<ol>
<li>Solution1: 经典DP
<ul>
<li><code>dp[i] = Math.min((dp[i - 1] + cost[i - 1]),(dp[i - 2] + cost[i - 2]))</code></li>
</ul>
</li>
</ol>
<h2 id="766-托普利茨矩阵">[766] 托普利茨矩阵</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/toeplitz-matrix/description/">https://leetcode-cn.com/problems/toeplitz-matrix/description/</a></li>
</ul>
<ol>
<li>Solution1, 遍历, Time: O(mn), Space: O(1), Runtime: 100%
<ul>
<li>遍历，比较元素和左上角元素是否相等</li>
</ul>
</li>
</ol>
<h2 id="771-宝石与石头">[771] 宝石与石头</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/jewels-and-stones/description/">https://leetcode-cn.com/problems/jewels-and-stones/description/</a></li>
<li>简单<code>HashMap</code></li>
</ul>
<h2 id="783-二叉搜索树节点最小距离">[783] 二叉搜索树节点最小距离</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/description/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/description/</a></li>
</ul>
<ol>
<li>Solution1, 遍历，放到list，排序后再遍历，Time: O(n), Space: O(n), Runtime: 70%</li>
<li>Solution2，中序遍历，遍历过程中记录<code>pre</code>并比较, Time: O(n), Space: O(1), Runtime: 96%
<ul>
<li><strong>二叉搜索树中序遍历得到的值序列是递增有序的</strong></li>
</ul>
</li>
</ol>
<h2 id="830-较大分组的位置">[830] 较大分组的位置</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/positions-of-large-groups/description/">https://leetcode-cn.com/problems/positions-of-large-groups/description/</a></li>
</ul>
<ol>
<li>Solution1: 双指针
<ul>
<li><code>i</code> 从头遍历, <code>j</code> 从 <code>i</code> 位置往后遍历，计数，满足条件放入 <code>List</code></li>
<li>当前区间满足条件后需将 <code>i</code> 置到 <code>j</code> 处，否则会从 <code>i + 1</code> 继续遍历，如果存在区间长度 <code>&gt;= 4</code> 会出现重复</li>
</ul>
</li>
</ol>
<h2 id="844-比较含退格的字符串">[844] 比较含退格的字符串</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/backspace-string-compare/description/">https://leetcode-cn.com/problems/backspace-string-compare/description/</a></li>
<li>栈比字符串性能高挺多</li>
</ul>
<h2 id="852-山脉数组的峰顶索引">[852] 山脉数组的峰顶索引</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/description/">https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/description/</a></li>
</ul>
<ol>
<li>Solution1, 单指针, Time: O(n), Space: O(1), Runtime: 91%
<ul>
<li>从左到右遍历，找最大值位变小的前一位，即最大值，即山峰</li>
</ul>
</li>
<li>Solution2, 二分查找, Time: O(logn), Space: O(1), Runtime: 91%
<ul>
<li>左右之间二分，即寻找最小的 i，使 <code>arr[i] &gt; arr[i + 1]</code></li>
<li>若 <code>arr[mid] &gt; arr[mid + 1]</code>，即<code>[mid, right]</code>见为递减，即答案在<code>[left, mid]</code>中，反之则在<code>[mid, right]</code>中</li>
</ul>
</li>
</ol>
<h2 id="860-柠檬水找零">[860] 柠檬水找零</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/lemonade-change/description/">https://leetcode-cn.com/problems/lemonade-change/description/</a></li>
<li>维护两个变量，统计5和10的个数</li>
<li>对每个bill需要找零的情况分情况讨论
<ul>
<li>5: 不找</li>
<li>10: 找5，收10</li>
<li>20: 找三张5，或一张5一张10</li>
</ul>
</li>
</ul>
<h2 id="872-叶子相似的树">[872] 叶子相似的树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/leaf-similar-trees/description/">https://leetcode-cn.com/problems/leaf-similar-trees/description/</a></li>
</ul>
<ol>
<li>Solution1, DFS两次遍历, Time: O(m + n), Space: O(m + n), Runtime: 91%
<ul>
<li>DFS遍历两棵树，结果放入两个<code>list</code>中，最后比较是否相等</li>
</ul>
</li>
</ol>
<h2 id="876-链表的中间结点">[876] 链表的中间结点</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/description/">https://leetcode-cn.com/problems/middle-of-the-linked-list/description/</a></li>
<li>快慢指针，注意 if( p.next! = null )</li>
</ul>
<h2 id="888-公平的糖果交换">[888] 公平的糖果交换</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/fair-candy-swap/description/">https://leetcode-cn.com/problems/fair-candy-swap/description/</a></li>
</ul>
<ol>
<li>Solution1, 暴力，Time: O(n * m), Space: O(1), Runtime: 15%</li>
<li>Solution2, 二分，Time: O(max(m, n)), Space: O(1), Runtime: 48%
<ul>
<li>先计算 <code>count(A)</code> 和 <code>count(B)</code>的总差值<code>aCount - (aCount + bCount) / 2</code>，再 <code>sort(A), sort(B)</code> 后双指针遍历</li>
<li>比较 <code>A[i] - B[j]</code>与总差值的大小，若大于总差值则表示当前 <code>B[j]</code> 不够填补差值，<code>j += 1</code>；反之 <code>i += 1</code></li>
</ul>
</li>
</ol>
<h2 id="938-二叉搜索树的范围和">[938] 二叉搜索树的范围和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/range-sum-of-bst/description/">https://leetcode-cn.com/problems/range-sum-of-bst/description/</a></li>
</ul>
<ol>
<li>Solution1, Naive DFS, Time: O(n), Space: O(n), Runtime: 48%</li>
<li>Solution2, 优雅 DFS, Time: O(n), Space: O(n), Runtime: 58%</li>
<li>Solution3, 非递归 BFS, Time: O(n), Space: O(n), Runtime: 58%</li>
</ol>
<h2 id="993-二叉树的堂兄弟节点">[993] 二叉树的堂兄弟节点</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/description/">https://leetcode-cn.com/problems/cousins-in-binary-tree/description/</a></li>
</ul>
<ol>
<li>Solution1, BFS, Time: O(n), Space: O(n), Runtime: 98%
<ul>
<li>遍历一遍树，保存到HashSet, K: 节点值, V: 节点深度和父节点</li>
<li>取HashSet，parent不相等且depth相等</li>
<li>优化：只存x和y，Space: O(n) -&gt; O(1)</li>
</ul>
</li>
</ol>
<h2 id="997-找到小镇的法官">[997] 找到小镇的法官</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/find-the-town-judge/description/">https://leetcode-cn.com/problems/find-the-town-judge/description/</a></li>
<li>有向图，[a, b]表示从顶点a出发指向顶点b的一条有向边。</li>
<li>是否存在且只存在一个顶点，所有的顶点都指向他，但是这个点不指向任何点。</li>
<li>即该顶点的入度是N - 1，出度是0。</li>
<li>使用一个数组存储每个点的入度和出度的差，当某个点的入度和出度的差是N - 1时，代表他是法官，否则不存在。</li>
<li>证明：如果入度和出度的差 = N - 1，又入度、出度 &gt;= 0，那么入度 = N- 1，出度 = 0，满足条件1和2。一旦存在一个点满足条件，那么说明这个点没有出度，所以不存在另一个点的入度是N - 1，满足条件3。</li>
</ul>
<h2 id="1018-可被-5-整除的二进制前缀">[1018] 可被 5 整除的二进制前缀</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/description/">https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/description/</a></li>
</ul>
<ol>
<li>Solution1, Time: O(n), Space: O(1), Runtime: 93%
<ul>
<li>能否被 <code>5</code> 整除只与末位有关，所以每次算完一位 <code>%= 10</code>，不能暴力算下去，不然 <code>double</code> 也会越界</li>
<li><code>&lt;&lt;= 1</code> 代替 <code>*= 2</code>，加速运算</li>
</ul>
</li>
</ol>
<h2 id="1046-最后一块石头的重量">[1046] 最后一块石头的重量</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/last-stone-weight/">https://leetcode-cn.com/problems/last-stone-weight/</a></li>
</ul>
<h2 id="1128-等价多米诺骨牌对的数量">[1128] 等价多米诺骨牌对的数量</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/description/">https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/description/</a></li>
</ul>
<ol>
<li>Solution1, 二元组表示，Time: O(n), Space: O(1), Runtime: 99%
<ul>
<li><code>1 &lt;= dominoes[i][j] &lt;= 9</code> 可得 <code>i + j &lt;= 99</code></li>
<li>使用数组 <code>i * 10 + j / j * 10 + i</code> 储存每对的<code>index</code></li>
<li>要计算的是可以有多少对，例如三张相同的牌，可以组成三对 <code>res = index * (index - 1) / 2</code></li>
</ul>
</li>
</ol>
<h2 id="1232-缀点成线">[1232] 缀点成线</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/description/">https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/description/</a></li>
</ul>
<ol>
<li>Solution1, 改良斜率法，Time: O(n), Space: O(1), Runtime: 100%
<ul>
<li>只存在两个点直接 <code>return</code></li>
<li>检查第三个点与12两点之间的斜率是否相等(乘法计算替代除法，防止除数corner case为 <code>0</code>)</li>
<li>判断 <code>Δy1 / Δx1 == Δy2 / Δx2 -&gt; Δy1 * Δx2 == Δx1 * Δy2</code>, 哪两个<code>Δ</code>相乘不要搞错</li>
</ul>
</li>
</ol>
<h2 id="1266-访问所有点的最小时间">[1266] 访问所有点的最小时间</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/description/">https://leetcode-cn.com/problems/minimum-time-visiting-all-points/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-le-2/">https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-le-2/</a></li>
</ul>
<ol>
<li>Solution1: 切比雪夫距离
<ul>
<li>两点 <code>(x0, y0), (x1, y1)</code> 之间的距离差为 <code>dx = Math.abs(x0 - x1), dy = Math.abs(y0 - y1)</code>
<ol>
<li><code>dx &lt; dy</code>：沿对角线移动 <code>dx</code> 次，再竖直移动 <code>dy - dx</code> 次，总计 <code>dx + (dy - dx) = dy</code> 次</li>
<li><code>dx == dy</code>：沿对角线移动 <code>dx</code> 次</li>
<li><code>dx &gt; dy</code>：沿对角线移动 <code>dy</code> 次，再水平移动 <code>dx - dy</code> 次，总计 <code>dy + (dx - dy) = dx</code> 次</li>
</ol>
</li>
<li>最少移动次数为 <code>Math.max(dx, dy)</code></li>
</ul>
</li>
</ol>
<h2 id="1342-将数字变成-0-的操作次数">[1342] 将数字变成 0 的操作次数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/description/">https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/description/</a></li>
</ul>
<ol>
<li>Solution1: 奇数 <code>-1</code>，偶数 <code>/2</code>，Time: O(logn), Space: O(1), Runtime: 100%</li>
</ol>
<h2 id="1346-检查整数及其两倍数是否存在">[1346] 检查整数及其两倍数是否存在</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/check-if-n-and-its-double-exist/description/">https://leetcode-cn.com/problems/check-if-n-and-its-double-exist/description/</a></li>
</ul>
<ol>
<li>Solution1: HashSet
<ul>
<li>简单<code>HashSet</code>，用<code>float</code>加速判断</li>
<li>Runtime: 87%</li>
</ul>
</li>
</ol>
<h2 id="1486-数组异或操作">[1486] 数组异或操作</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/description/">https://leetcode-cn.com/problems/xor-operation-in-an-array/description/</a></li>
</ul>
<ol>
<li>Solution1, 直接计算，Time: O(n), Space: O(1), Runtime: 64%</li>
</ol>
<h2 id="1603-设计停车系统">[1603] 设计停车系统</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/design-parking-system/description/">https://leetcode-cn.com/problems/design-parking-system/description/</a></li>
</ul>
<ol>
<li>Solution1, 数组模拟, Time: O(1), Space: O(1), Runtime: 100%</li>
</ol>
<h2 id="1720-解码异或后的数组">[1720] 解码异或后的数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/decode-xored-array/description/">https://leetcode-cn.com/problems/decode-xored-array/description/</a></li>
</ul>
<ol>
<li>Solution1, 反向异或, Time: O(n), Space: O(1), Runtime: 57%
<ul>
<li><code>encode[i] = arr[i] XOR arr[i + 1]</code></li>
<li><code>encode[i - 1] = arr[i - 1] XOR arr[i]</code></li>
<li><code>encode[i - 1] XOR arr[i - 1] = arr[i]</code></li>
</ul>
</li>
</ol>
<h2 id="剑指-offer-53---ii-0n-1中缺失的数字">剑指 Offer 53 - II. 0～n-1中缺失的数字</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/</a></li>
</ul>
<ol>
<li>Solution1: 二分，Time: O(logn), Space: O(1), Runtime: 100%
<ul>
<li><strong>对于有序数组，都应该想到二分</strong></li>
<li>key: 左子数组: <code>nums[i] == i</code>; 右子数组: <code>nums[i] != i</code>;</li>
<li>二分查找，左右两指针，<code>left = mid - 1 / right = mid + 1</code>，迭代，判断，返回</li>
</ul>
</li>
</ol>

                    </div>
                    
                    

                    

                    
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">下一页</span>
        <a href="/zh/docs/notes/medium/" class="block">Medium</a>
        
    </div>
</div>

                    

<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zjoey" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


                </div>
                
                <div class="hidden lg:block lg:w-1/4">
                    
                    <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-secondary-bg pt-16 -mt-16 ">
    <span class="text-lg font-semibold">本页内容</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6  pt-10 -mt-10 border-l ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-two-sum-两数之和">[1] Two Sum 两数之和</a></li>
    <li><a href="#7-reverse-int">[7] Reverse Int</a></li>
    <li><a href="#9-ispalindrome">[9] isPalindrome</a></li>
    <li><a href="#14-longestcommonprefix">[14] longestCommonPrefix</a></li>
    <li><a href="#20-valid-parentheses判断对等括号">[20] Valid Parentheses，判断对等括号</a></li>
    <li><a href="#26-remove-duplicated-from-sorted-array-删除排序数组中的重复项">[26] Remove Duplicated from Sorted Array 删除排序数组中的重复项</a></li>
    <li><a href="#27-remove-element-移除元素">[27] Remove Element 移除元素</a></li>
    <li><a href="#28-实现-strstr">[28] 实现 strStr()</a></li>
    <li><a href="#35-search-insert-position-搜索插入位置">[35] Search Insert Position 搜索插入位置</a></li>
    <li><a href="#38-count-and-say-外观数列">[38] Count and Say 外观数列</a></li>
    <li><a href="#53-maximum-subarray">[53] Maximum Subarray</a></li>
    <li><a href="#58-最后一个单词的长度">[58] 最后一个单词的长度</a></li>
    <li><a href="#66-plus-one">[66] Plus One</a></li>
    <li><a href="#67-二进制求和">[67] 二进制求和</a></li>
    <li><a href="#70-爬楼梯">[70] 爬楼梯</a></li>
    <li><a href="#83-删除排序链表中的重复元素">[83] 删除排序链表中的重复元素</a></li>
    <li><a href="#88-merge-sorted-array">[88] Merge Sorted Array</a></li>
    <li><a href="#100-相同的树">[100] 相同的树</a></li>
    <li><a href="#101-对称二叉树">[101] 对称二叉树</a></li>
    <li><a href="#104-二叉树的最大深度">[104] 二叉树的最大深度</a></li>
    <li><a href="#107-二叉树的层次遍历-ii">[107] 二叉树的层次遍历 II</a></li>
    <li><a href="#108-将有序数组转换为二叉搜索树">[108] 将有序数组转换为二叉搜索树</a></li>
    <li><a href="#110-平衡二叉树">[110] 平衡二叉树</a></li>
    <li><a href="#111-二叉树的最小深度">[111] 二叉树的最小深度</a></li>
    <li><a href="#112-路径总和">[112] 路径总和</a></li>
    <li><a href="#118-杨辉三角">[118] 杨辉三角</a></li>
    <li><a href="#119-杨辉三角2">[119] 杨辉三角2</a></li>
    <li><a href="#121-best-time-to-buy-and-sell-stock买卖股票的最佳时机">[121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机</a></li>
    <li><a href="#122-best-time-to-buy-and-sell-stock-ii买卖股票的最佳时机-ii">[122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II</a></li>
    <li><a href="#125-验证回文串">[125] 验证回文串</a></li>
    <li><a href="#136-singlenumber">[136] SingleNumber</a></li>
    <li><a href="#141-环形链表">[141] 环形链表</a></li>
    <li><a href="#155-最小栈">[155] 最小栈</a></li>
    <li><a href="#160-相交链表">[160] 相交链表</a></li>
    <li><a href="#167-两数之和-ii---输入有序数组">[167] 两数之和 II - 输入有序数组</a></li>
    <li><a href="#168-excel表列名称">[168] Excel表列名称</a></li>
    <li><a href="#169-多数元素">[169] 多数元素</a></li>
    <li><a href="#171-excel表列序号">[171] Excel表列序号</a></li>
    <li><a href="#172-阶乘后的零">[172] 阶乘后的零</a></li>
    <li><a href="#189-旋转数组">[189] 旋转数组</a></li>
    <li><a href="#190-颠倒二进制位">[190] 颠倒二进制位</a></li>
    <li><a href="#191-位1的个数">[191] 位1的个数</a></li>
    <li><a href="#198-打家劫舍">[198] 打家劫舍</a></li>
    <li><a href="#202-happy-number">[202] Happy Number</a></li>
    <li><a href="#203-移除链表元素">[203] 移除链表元素</a></li>
    <li><a href="#204-计数质数">[204] 计数质数</a></li>
    <li><a href="#205-同构字符串">[205] 同构字符串</a></li>
    <li><a href="#206-reverse-linked-list">[206] Reverse Linked List</a></li>
    <li><a href="#217-存在重复元素">[217] 存在重复元素##</a></li>
    <li><a href="#219-存在重复元素-ii">[219] 存在重复元素 II</a></li>
    <li><a href="#225-用队列实现栈">[225] 用队列实现栈</a></li>
    <li><a href="#226-翻转二叉树">[226] 翻转二叉树</a></li>
    <li><a href="#228-汇总区间">[228] 汇总区间</a></li>
    <li><a href="#231-2的幂">[231] 2的幂</a></li>
    <li><a href="#232-用栈实现队列">[232] 用栈实现队列</a></li>
    <li><a href="#234-回文链表">[234] 回文链表</a></li>
    <li><a href="#235-二叉搜索树的最近公共祖先">[235] 二叉搜索树的最近公共祖先</a></li>
    <li><a href="#237-删除链表中的节点">[237] 删除链表中的节点</a></li>
    <li><a href="#242-有效的字母异位词">[242] 有效的字母异位词</a></li>
    <li><a href="#257-二叉树的所有路径">[257] 二叉树的所有路径</a></li>
    <li><a href="#258-各位相加">[258] 各位相加</a></li>
    <li><a href="#263-丑数">[263] 丑数</a></li>
    <li><a href="#268-缺失数字">[268] 缺失数字</a></li>
    <li><a href="#278-第一个错误的版本">[278] 第一个错误的版本</a></li>
    <li><a href="#283--move-zeros0元素移到最后其他不变">[283]  Move Zeros，0元素移到最后，其他不变</a></li>
    <li><a href="#290-单词规律">[290] 单词规律</a></li>
    <li><a href="#344-反转字符串">[344] 反转字符串##</a></li>
    <li><a href="#350-两个数组的交集-ii">[350] 两个数组的交集 II</a></li>
    <li><a href="#367-有效的完全平方数">[367] 有效的完全平方数</a></li>
    <li><a href="#371-两整数之和">[371] 两整数之和</a></li>
    <li><a href="#383-赎金信">[383] 赎金信</a></li>
    <li><a href="#387-字符串中的第一个唯一字符">[387] 字符串中的第一个唯一字符</a></li>
    <li><a href="#389-找不同">[389] 找不同</a></li>
    <li><a href="#455-分发饼干">[455] 分发饼干</a></li>
    <li><a href="#674-最长连续递增序列">[674] 最长连续递增序列</a></li>
    <li><a href="#476-数字的补数">[476] 数字的补数</a></li>
    <li><a href="#496-下一个更大元素-i">[496] 下一个更大元素 I</a></li>
    <li><a href="#509-斐波那契数">[509] 斐波那契数</a></li>
    <li><a href="#543-二叉树的直径">[543] 二叉树的直径</a></li>
    <li><a href="#643-子数组最大平均数-i">[643] 子数组最大平均数 I</a></li>
    <li><a href="#645-错误的集合">[645] 错误的集合</a></li>
    <li><a href="#690-员工的重要性">[690] 员工的重要性</a></li>
    <li><a href="#746-使用最小花费爬楼梯">[746] 使用最小花费爬楼梯</a></li>
    <li><a href="#766-托普利茨矩阵">[766] 托普利茨矩阵</a></li>
    <li><a href="#771-宝石与石头">[771] 宝石与石头</a></li>
    <li><a href="#783-二叉搜索树节点最小距离">[783] 二叉搜索树节点最小距离</a></li>
    <li><a href="#830-较大分组的位置">[830] 较大分组的位置</a></li>
    <li><a href="#844-比较含退格的字符串">[844] 比较含退格的字符串</a></li>
    <li><a href="#852-山脉数组的峰顶索引">[852] 山脉数组的峰顶索引</a></li>
    <li><a href="#860-柠檬水找零">[860] 柠檬水找零</a></li>
    <li><a href="#872-叶子相似的树">[872] 叶子相似的树</a></li>
    <li><a href="#876-链表的中间结点">[876] 链表的中间结点</a></li>
    <li><a href="#888-公平的糖果交换">[888] 公平的糖果交换</a></li>
    <li><a href="#938-二叉搜索树的范围和">[938] 二叉搜索树的范围和</a></li>
    <li><a href="#993-二叉树的堂兄弟节点">[993] 二叉树的堂兄弟节点</a></li>
    <li><a href="#997-找到小镇的法官">[997] 找到小镇的法官</a></li>
    <li><a href="#1018-可被-5-整除的二进制前缀">[1018] 可被 5 整除的二进制前缀</a></li>
    <li><a href="#1046-最后一块石头的重量">[1046] 最后一块石头的重量</a></li>
    <li><a href="#1128-等价多米诺骨牌对的数量">[1128] 等价多米诺骨牌对的数量</a></li>
    <li><a href="#1232-缀点成线">[1232] 缀点成线</a></li>
    <li><a href="#1266-访问所有点的最小时间">[1266] 访问所有点的最小时间</a></li>
    <li><a href="#1342-将数字变成-0-的操作次数">[1342] 将数字变成 0 的操作次数</a></li>
    <li><a href="#1346-检查整数及其两倍数是否存在">[1346] 检查整数及其两倍数是否存在</a></li>
    <li><a href="#1486-数组异或操作">[1486] 数组异或操作</a></li>
    <li><a href="#1603-设计停车系统">[1603] 设计停车系统</a></li>
    <li><a href="#1720-解码异或后的数组">[1720] 解码异或后的数组</a></li>
    <li><a href="#剑指-offer-53---ii-0n-1中缺失的数字">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
                    
                </div>
                
            </div>

        </div>


    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        hljs.initHighlightingOnLoad();
        changeSidebarHeight();
        switchDocToc();
    })
</script>









            </div>
        </div>
        
    </main>
    <footer class="pl-scrollbar">
        <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2020 <a href="https://www.zjoey.com/">z. Joey &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
    </footer>
</body>

</html>