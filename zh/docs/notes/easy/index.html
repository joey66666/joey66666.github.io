<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>Easy | Leetcode-cn 笔记 | 片刻静思</title>
<link rel="stylesheet" href="/css/eureka.min.css">
<script defer src="/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112541018-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-112541018-1');
</script>


<link rel="icon" type="image/png" sizes="32x32" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_2.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_2.png">

<meta name="description"
  content="
[1] Two Sum 两数之和
[7] Reverse Int
[9] isPalindrome
[14] longestCommonPrefix
">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Leetcode 解题笔记",
      "item":"/zh/docs/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Leetcode-cn 笔记",
      "item":"/zh/docs/notes/"},{
      "@type": "ListItem",
      "position": 3 ,
      "name":"Easy",
      "item":"/zh/docs/notes/easy/"}]
}
</script><script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/zh/docs/notes/easy/"
    },
    "headline": "Easy | Leetcode-cn 笔记 | 片刻静思","datePublished": "2020-12-17T22:26:52+08:00",
    "dateModified": "2020-12-17T22:26:52+08:00",
    "wordCount":  5459 ,
    "publisher": {
        "@type": "Person",
        "name": "z. Joey",
        "logo": {
            "@type": "ImageObject",
            "url": "/images/icon.png"
        }
        },
    "description": "\u003cul\u003e\n\u003cli\u003e\u003ca href=\u0022#1-two-sum-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C\u0022\u003e[1] Two Sum 两数之和\u003c\/a\u003e\u003c\/li\u003e\n\u003cli\u003e\u003ca href=\u0022#7-reverse-int\u0022\u003e[7] Reverse Int\u003c\/a\u003e\u003c\/li\u003e\n\u003cli\u003e\u003ca href=\u0022#9-ispalindrome\u0022\u003e[9] isPalindrome\u003c\/a\u003e\u003c\/li\u003e\n\u003cli\u003e\u003ca href=\u0022#14-longestcommonprefix\u0022\u003e[14] longestCommonPrefix\u003c\/a\u003e\u003c\/li\u003e\n\u003c\/ul\u003e"
}
</script><meta property="og:title" content="Easy | Leetcode-cn 笔记 | 片刻静思" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/images/icon.png">


<meta property="og:url" content="/zh/docs/notes/easy/" />




<meta property="og:description" content="
[1] Two Sum 两数之和
[7] Reverse Int
[9] isPalindrome
[14] longestCommonPrefix
" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="片刻静思" />






<meta property="article:published_time" content="2020-12-17T22:26:52&#43;08:00" />


<meta property="article:modified_time" content="2020-12-17T22:26:52&#43;08:00" />



<meta property="article:section" content="docs" />




<body class="flex flex-col min-h-screen">
    <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
        <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if ((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) {
        document.getElementsByTagName('html')[0].classList.add('dark')
    } else if (storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap p-4">
    <a href="/zh" class="mr-6 text-primary-text text-xl font-bold">片刻静思</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0" id="current-url"
            currenturl="/zh/docs/notes/easy/">
            <a href="/zh/posts/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">随笔</a>
            <a href="/zh/quotation/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">摘录</a>
            <a href="/zh/docs/"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">Leetcode-cn</a>
            <a href="/zh/authors/joey"
                class="block mt-4 md:inline-block md:mt-0 hover:text-eureka mr-4 main-a">关于</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka">Light</span>
                    <span class="px-4 py-1 hover:text-eureka">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka">Auto</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            switchMode('Auto')
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });

    let currenturl = document.getElementById('current-url').getAttribute('currenturl')
        if (currenturl.length > 1) {
            currenturl = currenturl.substr(0, currenturl.length - 1)
        }

        sessionStorage.setItem("mainKey", currenturl)

        let elements = document.getElementsByClassName('main-a');
        for (let i in elements) {
            if (typeof elements[i] === "object") {
                let elementurl = elements[i].getAttribute('href')
                if (elementurl.length > 1 && elementurl.charAt(elementurl.length - 1) == '/') {
                    elementurl = elementurl.substr(0, elementurl.length - 1)
                }
                if (elementurl == sessionStorage.getItem("mainKey")) {
                    elements[i].classList.add('text-eureka')
                } else {
                    elements[i].classList.remove('text-eureka')
                }
            }
        }
</script></div>
    </header>
    <main class="flex-grow pt-16">
        <div class="pl-scrollbar">
            <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="lg:pt-12">
    <div class="flex flex-col md:flex-row bg-secondary-bg rounded">
        <div class="md:w-1/4 lg:w-1/5 border-r">
            <div class="sticky top-16 pt-6">
                




<div id="sidebar-title" class="md:hidden mx-4 px-2 pt-4 pb-2 md:border-b text-tertiary-text md:text-primary-text">
    <span class="font-semibold">目录</span>
    <i class="fas fa-caret-right ml-1"></i>
</div>

<div id="sidebar-toc"
    class="hidden md:block overflow-y-auto mx-6 md:mx-0 pr-6 pt-2 md:max-h-doc-sidebar bg-primary-bg md:bg-transparent">
    <div class="flex flex-wrap ml-4 -mr-2 p-2 bg-secondary-bg md:bg-primary-bg rounded">
        <a class=" hover:text-eureka"
            href="/zh/docs/notes/">Leetcode-cn 笔记</a>
        
        
        


    </div>
    
<ul class="pl-6">
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" text-eureka  hover:text-eureka"
                href="/zh/docs/notes/easy/">Easy</a>
        </div>
        
    </li>
    
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" hover:text-eureka"
                href="/zh/docs/notes/medium/">Medium</a>
        </div>
        
    </li>
    
    
    
    
    <li class="py-2">
        <div class="">
            <a class=" hover:text-eureka"
                href="/zh/docs/notes/hard/">Hard</a>
        </div>
        
    </li>
    
    
</ul>

</div>





            </div>

        </div>
        <div class="w-full md:w-3/4 lg:w-4/5 pb-8 pt-2 md:pt-8">
            <div class="w-full lg:w-3/4 pl-6 ml-0 mr-auto">
                <h1 class="font-bold text-3xl text-primary-text">Easy</h1>
                <div class="flex flex-wrap flex-row items-center my-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2020-12-17</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>11分钟阅读时长</span>
    </div>
    
    

    
</div>
            </div>
            <div class="flex">
                <div class="w-full lg:w-3/4 px-6">
                    
                    
                    <div class="content">
                        <ul>
<li><a href="#1-two-sum-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">[1] Two Sum 两数之和</a></li>
<li><a href="#7-reverse-int">[7] Reverse Int</a></li>
<li><a href="#9-ispalindrome">[9] isPalindrome</a></li>
<li><a href="#14-longestcommonprefix">[14] longestCommonPrefix</a></li>
</ul>
<ul>
<li><a href="#20-valid-parentheses%E5%88%A4%E6%96%AD%E5%AF%B9%E7%AD%89%E6%8B%AC%E5%8F%B7">[20] Valid Parentheses，判断对等括号</a></li>
<li><a href="#26-remove-duplicated-from-sorted-array-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">[26] Remove Duplicated from Sorted Array 删除排序数组中的重复项</a></li>
<li><a href="#27-remove-element-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">[27] Remove Element 移除元素</a></li>
<li><a href="#28-%E5%AE%9E%E7%8E%B0-strstr">[28] 实现 strStr()</a></li>
<li><a href="#35-search-insert-position-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE">[35] Search Insert Position 搜索插入位置</a></li>
<li><a href="#38-count-and-say-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97">[38] Count and Say 外观数列</a></li>
<li><a href="#53-maximum-subarray">[53] Maximum Subarray</a></li>
<li><a href="#58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6">[58] 最后一个单词的长度</a></li>
<li><a href="#66-plus-one">[66] Plus One</a></li>
<li><a href="#67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C">[67] 二进制求和</a></li>
<li><a href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF">[70] 爬楼梯</a></li>
<li><a href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">[83] 删除排序链表中的重复元素</a></li>
<li><a href="#88-merge-sorted-array">[88] Merge Sorted Array</a></li>
<li><a href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91">[100] 相同的树</a></li>
<li><a href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">[101] 对称二叉树</a></li>
<li><a href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">[104] 二叉树的最大深度</a></li>
<li><a href="#107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-ii">[107] 二叉树的层次遍历 II</a></li>
<li><a href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">[108] 将有序数组转换为二叉搜索树</a></li>
<li><a href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">[110] 平衡二叉树</a></li>
<li><a href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6">[111] 二叉树的最小深度</a></li>
<li><a href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C">[112] 路径总和</a></li>
<li><a href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92">[118] 杨辉三角</a></li>
<li><a href="#119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922">[119] 杨辉三角2</a></li>
<li><a href="#121-best-time-to-buy-and-sell-stock%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">[121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机</a></li>
<li><a href="#122-best-time-to-buy-and-sell-stock-ii%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii">[122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II</a></li>
<li><a href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2">[125] 验证回文串</a></li>
<li><a href="#136-singlenumber">[136] SingleNumber</a></li>
<li><a href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">[141] 环形链表</a></li>
<li><a href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88">[155] 最小栈</a></li>
<li><a href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8">[160] 相交链表</a></li>
<li><a href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii---%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">[167] 两数之和 II - 输入有序数组</a></li>
<li><a href="#168-excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0">[168] Excel表列名称</a></li>
<li><a href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0">[169] 多数元素</a></li>
<li><a href="#171-excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7">[171] Excel表列序号</a></li>
<li><a href="#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6">[172] 阶乘后的零</a></li>
<li><a href="#189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84">[189] 旋转数组</a></li>
<li><a href="#190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D">[190] 颠倒二进制位</a></li>
<li><a href="#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0">[191] 位1的个数</a></li>
<li><a href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">[198] 打家劫舍</a></li>
<li><a href="#202-happy-number">[202] Happy Number</a></li>
<li><a href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0">[203] 移除链表元素</a></li>
<li><a href="#204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0">[204] 计数质数</a></li>
<li><a href="#205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2">[205] 同构字符串</a></li>
<li><a href="#206-reverse-linked-list">[206] Reverse Linked List</a></li>
<li><a href="#217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">[217] 存在重复元素##</a></li>
<li><a href="#219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii">[219] 存在重复元素 II</a></li>
<li><a href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88">[225] 用队列实现栈</a></li>
<li><a href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">[226] 翻转二叉树</a></li>
<li><a href="#231-2%E7%9A%84%E5%B9%82">[231] 2的幂</a></li>
<li><a href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">[232] 用栈实现队列</a></li>
<li><a href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">[234] 回文链表</a></li>
<li><a href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">[235] 二叉搜索树的最近公共祖先</a></li>
<li><a href="#237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9">[237] 删除链表中的节点</a></li>
<li><a href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">[242] 有效的字母异位词</a></li>
<li><a href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84">[257] 二叉树的所有路径</a></li>
<li><a href="#258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0">[258] 各位相加</a></li>
<li><a href="#263-%E4%B8%91%E6%95%B0">[263] 丑数</a></li>
<li><a href="#268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97">[268] 缺失数字</a></li>
<li><a href="#278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC">[278] 第一个错误的版本</a></li>
<li><a href="#283--move-zeros0%E5%85%83%E7%B4%A0%E7%A7%BB%E5%88%B0%E6%9C%80%E5%90%8E%E5%85%B6%E4%BB%96%E4%B8%8D%E5%8F%98">[283]  Move Zeros，0元素移到最后，其他不变</a></li>
<li><a href="#290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B">[290] 单词规律</a></li>
<li><a href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">[344] 反转字符串##</a></li>
<li><a href="#350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-ii">[350] 两个数组的交集 II</a></li>
<li><a href="#367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0">[367] 有效的完全平方数</a></li>
<li><a href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1">[383] 赎金信</a></li>
<li><a href="#387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6">[387] 字符串中的第一个唯一字符</a></li>
<li><a href="#476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0">[476] 数字的补数</a></li>
<li><a href="#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-i">[496] 下一个更大元素 I</a></li>
<li><a href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84">[543] 二叉树的直径</a></li>
<li><a href="#771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4">[771] 宝石与石头</a></li>
<li><a href="#844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">[844] 比较含退格的字符串</a></li>
<li><a href="#860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6">[860] 柠檬水找零##</a></li>
<li><a href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9">[876] 链表的中间结点</a></li>
<li><a href="#993-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9">[993] 二叉树的堂兄弟节点</a></li>
<li><a href="#997-%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98">[997] 找到小镇的法官</a></li>
<li><a href="#1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F">[1046] 最后一块石头的重量</a></li>
<li><a href="#1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF">[1232] 缀点成线</a></li>
</ul>
<h1 id="easy">Easy</h1>
<h2 id="1-two-sum-两数之和">[1] Two Sum 两数之和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></li>
<li>HashSet</li>
<li>使用一个 HashMap，来建立数字和其坐标位置之间的映射，在遍历数组的时候，用 target 减去遍历到的数字，就是另一个需要的数字了，直接在 HashMap 中查找其是否存在即可，注意要判断查找到的数字不是第一个数字，比如 target 是4，遍历到了一个2，那么另外一个2不能是之前那个2</li>
</ul>
<h2 id="7-reverse-int">[7] Reverse Int</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/reverse-integer/">https://leetcode-cn.com/problems/reverse-integer/</a></li>
<li>n = n * 10 + x % 10</li>
<li>通过<code>long n == int n</code>判断是否溢出</li>
</ul>
<h2 id="9-ispalindrome">[9] isPalindrome</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/palindrome-number/">https://leetcode-cn.com/problems/palindrome-number/</a></li>
</ul>
<h2 id="14-longestcommonprefix">[14] longestCommonPrefix</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-common-prefix">https://leetcode-cn.com/problems/longest-common-prefix</a></li>
</ul>
<ol>
<li>暴力，先内循环选定数组第一个元素，再外循环与数组内其他元素比较</li>
<li>从后往前裁剪至符合，若不符合则裁剪至空</li>
</ol>
<h2 id="20-valid-parentheses判断对等括号">[20] Valid Parentheses，判断对等括号</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a></li>
<li>根据 now 指向来 push 对应的括号，判断 pop 是否==对应</li>
</ul>
<h2 id="26-remove-duplicated-from-sorted-array-删除排序数组中的重复项">[26] Remove Duplicated from Sorted Array 删除排序数组中的重复项</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a></li>
<li>只需要前i个，后面不用管</li>
<li>return的count要+1，因为根据count来print数组</li>
</ul>
<h2 id="27-remove-element-移除元素">[27] Remove Element 移除元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a></li>
<li>循环中不动即跳过</li>
</ul>
<h2 id="28-实现-strstr">[28] 实现 strStr()</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/implement-strstr/description/">https://leetcode-cn.com/problems/implement-strstr/description/</a></li>
</ul>
<h2 id="35-search-insert-position-搜索插入位置">[35] Search Insert Position 搜索插入位置</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/search-insert-position">https://leetcode-cn.com/problems/search-insert-position</a></li>
<li>once &lt; or = 则返回，为插入位置</li>
<li>搜索不到返回 nums.length 即插入最大值位置</li>
<li>太巧妙了！</li>
</ul>
<h2 id="38-count-and-say-外观数列">[38] Count and Say 外观数列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-and-say/description/">https://leetcode-cn.com/problems/count-and-say/description/</a></li>
<li>这题挺有意思</li>
</ul>
<h2 id="53-maximum-subarray">[53] Maximum Subarray</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a></li>
<li>暴力, O(n^2). ## （不正确）##</li>
<li>DP 动态规划（初始状态 + 状态转移公式）</li>
</ul>
<h2 id="58-最后一个单词的长度">[58] 最后一个单词的长度</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/length-of-last-word/description/">https://leetcode-cn.com/problems/length-of-last-word/description/</a></li>
</ul>
<h2 id="66-plus-one">[66] Plus One</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></li>
<li>判断是否进位</li>
</ul>
<h2 id="67-二进制求和">[67] 二进制求和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/add-binary/description/">https://leetcode-cn.com/problems/add-binary/description/</a></li>
<li>当前位 = sum % 2，进位 = sum / 2，if (进位 != 0) { append 进位 }</li>
</ul>
<h2 id="70-爬楼梯">[70] 爬楼梯</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/climbing-stairs/description/">https://leetcode-cn.com/problems/climbing-stairs/description/</a></li>
<li>斐波那契数列找规律 ( res[i] = res[i-1]  + res[i-2] )</li>
<li><strong>直接递归 ( return res[i-1] + res[i-2] ) 会超时</strong></li>
</ul>
<h2 id="83-删除排序链表中的重复元素">[83] 删除排序链表中的重复元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/</a></li>
<li>删除重复节点后若 last 后移一位则会移到已删除的节点上，所以若重复 last 不动，不重复 last 后移一位</li>
</ul>
<h2 id="88-merge-sorted-array">[88] Merge Sorted Array</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a></li>
<li>排序好的数组，从后往前插入</li>
<li>比大小，大于从尾插，小于则swap</li>
<li>剩下直接插在头</li>
</ul>
<h2 id="100-相同的树">[100] 相同的树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/same-tree/description/">https://leetcode-cn.com/problems/same-tree/description/</a></li>
<li>递归写法</li>
</ul>
<h2 id="101-对称二叉树">[101] 对称二叉树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/symmetric-tree/description/">https://leetcode-cn.com/problems/symmetric-tree/description/</a></li>
<li>从外往内包裹着比较</li>
<li>不要想太复杂</li>
</ul>
<h2 id="104-二叉树的最大深度">[104] 二叉树的最大深度</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/</a></li>
</ul>
<h2 id="107-二叉树的层次遍历-ii">[107] 二叉树的层次遍历 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/description/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/description/</a></li>
<li>自顶向下存储，<code>reverse</code>后输出</li>
<li>完全遍历下一层：</li>
</ul>
<pre><code class="language-java">for ( TreeNode node : next_level ){
    vals.add( node.val );
}
</code></pre>
<h2 id="108-将有序数组转换为二叉搜索树">[108] 将有序数组转换为二叉搜索树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/</a></li>
<li>二叉平衡树定义：<code>left.val &lt; root.val &amp;&amp; right.val &gt; root.val</code></li>
<li>取中间值<code>(mid = (start + end) / 2)</code>为root，左边<code>nums[start, mid - 1]</code>为左子树，右边<code>nums[mid + 1, end]</code>为右子树</li>
</ul>
<h2 id="110-平衡二叉树">[110] 平衡二叉树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/description/">https://leetcode-cn.com/problems/balanced-binary-tree/description/</a></li>
<li>中间使用<code>-1</code>判断<code>false</code>，若<code>-1</code>则再次直接<code>return -1</code></li>
</ul>
<h2 id="111-二叉树的最小深度">[111] 二叉树的最小深度</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/</a></li>
<li>与 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">[104] 二叉树的最大深度 </a> 做法类似，https://github.com/joey66666/Algorithms/issues/2#issuecomment-612340952</li>
<li>注意区分<code>root.left != null, root.right != null</code> 的情况，分开讨论</li>
</ul>
<h2 id="112-路径总和">[112] 路径总和</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/path-sum/description/">https://leetcode-cn.com/problems/path-sum/description/</a></li>
<li>到叶子节点判断 <code>sum - root.val == 0</code>，没到叶子节点 <code>sum - root.val</code>继续递归 <code>root.left</code>或<code>root.right</code></li>
</ul>
<h2 id="118-杨辉三角">[118] 杨辉三角</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/pascals-triangle/">https://leetcode-cn.com/problems/pascals-triangle/</a></li>
<li>[i][0] = 1</li>
<li>[i][j] = [i-1][j-1] + [i-1][j]</li>
</ul>
<h2 id="119-杨辉三角2">[119] 杨辉三角2</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">https://leetcode-cn.com/problems/pascals-triangle-ii/</a></li>
<li>设置中间变量保存上一层，与当前层迭代更新</li>
</ul>
<h2 id="121-best-time-to-buy-and-sell-stock买卖股票的最佳时机">[121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/</a></li>
<li>典型DP，把握初始状态（ prices[0] ）和状态转移条件 ( now &lt; start &amp; now_profit &gt; last_profit )</li>
</ul>
<h2 id="122-best-time-to-buy-and-sell-stock-ii买卖股票的最佳时机-ii">[122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/</a></li>
<li><strong>包含当天买入，当天卖出的情况</strong></li>
<li>贪心体现在追求当下利润最大 ( now_profit &gt; 0 )</li>
</ul>
<h2 id="125-验证回文串">[125] 验证回文串</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-palindrome/description/">https://leetcode-cn.com/problems/valid-palindrome/description/</a></li>
</ul>
<h2 id="136-singlenumber">[136] SingleNumber</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></li>
</ul>
<ol>
<li>Solution1 HashSet, if ( ! s.add ( x ))  s.remove( x );</li>
<li>Solution2 异或运用尤其巧妙，0 ^ int = int，int ^ int = 0;</li>
</ol>
<h2 id="141-环形链表">[141] 环形链表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle/description/">https://leetcode-cn.com/problems/linked-list-cycle/description/</a></li>
<li>快慢指针，若存在环则指针总会相遇，以<code>fast != null &amp;&amp; fast.next != null</code>为循环条件</li>
</ul>
<h2 id="155-最小栈">[155] 最小栈</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/min-stack/description/">https://leetcode-cn.com/problems/min-stack/description/</a></li>
<li>用另一个栈保存最小元素，栈顶最小（不是最小push栈顶本身，保证两个栈大小相等）</li>
</ul>
<h2 id="160-相交链表">[160] 相交链表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/</a></li>
<li>计算长度差，长的先走到两边平齐，再一起走，相交则return，走到头不相交return null</li>
</ul>
<h2 id="167-两数之和-ii---输入有序数组">[167] 两数之和 II - 输入有序数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/</a></li>
<li>头尾指针，头尾和 &gt; target, 尾指针左移；头尾和 &lt; target, 头指针右移</li>
<li>Time: O(n)</li>
</ul>
<h2 id="168-excel表列名称">[168] Excel表列名称</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/description/">https://leetcode-cn.com/problems/excel-sheet-column-title/description/</a></li>
<li>思路：取余到底，转换成字母，再反向输出</li>
<li>n直接除以26会出错，如<code>52/26=2···0</code>，但在Excel用实际<code>AZ</code>表示，所以先<code>n -= 1</code>。深层原因即计算机以0为第一位，Excel以1为第一位</li>
<li><code>StringBuilder.append()</code>比<code>String += </code>速度快很多</li>
</ul>
<h2 id="169-多数元素">[169] 多数元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/majority-element/description/">https://leetcode-cn.com/problems/majority-element/description/</a></li>
</ul>
<ol>
<li>Solution1: HashMap
<ul>
<li>HashMap，过程中 <code>if hm.get(nums[i]) &gt; nums.length /2</code>则return</li>
<li>Runtime: 38%</li>
<li>Time: O(n), Space: O(n)</li>
</ul>
</li>
<li>Solution2: 摩尔投票法
<ul>
<li>假设 nums[0] 为最多元素，遍历，相同 + 1，不同 - 1</li>
<li>若归零，则前面其他和本身数量相等，对冲抵消，指针当下指向另一个数，换成另一个数，对后面继续遍历比较</li>
<li>Runtime: 99%</li>
<li>Time: O(n), Space: O(1)</li>
</ul>
</li>
</ol>
<h2 id="171-excel表列序号">[171] Excel表列序号</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/description/">https://leetcode-cn.com/problems/excel-sheet-column-number/description/</a></li>
<li><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/description/">[168] Excel表列名称</a>的反面题</li>
<li>等同 26 -&gt; 10 进制转换</li>
</ul>
<h2 id="172-阶乘后的零">[172] 阶乘后的零</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/">https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/</a></li>
<li>0 的个数，即 10 ^ 个数</li>
<li>10 = 5 * 2</li>
<li>2 的个数易得到，所以10的个数 = 5的个数</li>
<li>如15！中有15，10，5，结果为3</li>
</ul>
<h2 id="189-旋转数组">[189] 旋转数组</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/rotate-array/description/">https://leetcode-cn.com/problems/rotate-array/description/</a></li>
<li>Solution2, 三次翻转，第一次数组倒序，第二次以k为分界线前后子数组分别倒序</li>
<li>比如12345经过翻转就变成了54321，这样已经做到了把前面的数字放到后面去，但是还没有完全达到要求，只需要把12放在后面去，目标数组就是34512。与54321对比发现我们就只需要在把分界线前后数组再进行翻转一次就可得到目标数组了</li>
<li>Time:O(n) //O(2n)</li>
</ul>
<h2 id="190-颠倒二进制位">[190] 颠倒二进制位</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/reverse-bits/description/">https://leetcode-cn.com/problems/reverse-bits/description/</a></li>
<li>思路：把n最右边一位取出来，res左移一位后加到res上，循环移动32次</li>
</ul>
<pre><code>res = res * 2 + n % 2
n /= 2
</code></pre>
<ul>
<li>以上运算，有符号数下不能用，因为使用补码表示</li>
<li>应使用位操作实现：<code>n &amp; 1</code>来取最后一位</li>
</ul>
<pre><code>res = (res &lt;&lt; 1) | (n &amp; 1)
n &gt;&gt;= 1
</code></pre>
<ul>
<li>Time: O(logN)</li>
</ul>
<h2 id="191-位1的个数">[191] 位1的个数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-of-1-bits/description/">https://leetcode-cn.com/problems/number-of-1-bits/description/</a></li>
<li>取最低位数，为1相加</li>
</ul>
<h2 id="198-打家劫舍">[198] 打家劫舍</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/house-robber/description/">https://leetcode-cn.com/problems/house-robber/description/</a></li>
<li>维护一个一位数组 dp，其中 dp[i] 表示 [0, i] 区间可以抢夺的最大值，对当前i来说，有抢和不抢两种互斥的选择。</li>
<li>不抢：dp[i-1]（等价于去掉 nums[i] 只抢 [0, i-1] 区间最大值）</li>
<li>抢：dp[i-2] + nums[i]（等价于去掉 nums[i-1]）</li>
<li>比如 nums为{3, 2, 1, 5}，首先 dp[0]=3 , dp[1]，由于3比2大，所以抢第一个房子的3，当前房子的2不抢，则dp[1]=3。dp[2]由于不能抢相邻的，所以可以用再前面的一个的 dp 值加上当前的房间值，和当前房间的前面一个 dp 值比较，取较大值当做当前 dp 值</li>
<li>状态转移方程 dp[i] = max(num[i] + dp[i - 2], dp[i - 1]),</li>
<li>需要初始化 dp[0] 和 dp[1]，dp[0] 为 num[0]，dp[1] 为 max(num[0], num[1])</li>
</ul>
<h2 id="202-happy-number">[202] Happy Number</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/happy-number">https://leetcode-cn.com/problems/happy-number</a></li>
</ul>
<h2 id="203-移除链表元素">[203] 移除链表元素</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/description/">https://leetcode-cn.com/problems/remove-linked-list-elements/description/</a></li>
<li>在<code>head</code>前添加头节点(sentinel, dummyHead)</li>
<li>双指针遍历删除</li>
</ul>
<h2 id="204-计数质数">[204] 计数质数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-primes/description/">https://leetcode-cn.com/problems/count-primes/description/</a></li>
<li>质数：只有1和它本身两个因数的自然数（1不是质数）</li>
<li>从boolean[n]数组中，2开始反向去除所有的非质数(2的倍数，3的倍数，4的倍数&hellip;)，质数false，非质数true</li>
<li>遍历过程使用count记录true的个数</li>
</ul>
<h2 id="205-同构字符串">[205] 同构字符串</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/isomorphic-strings/description/">https://leetcode-cn.com/problems/isomorphic-strings/description/</a></li>
</ul>
<ol>
<li>Solution1，HashMap
<ul>
<li>HashMap&lt;Character, Character&gt;存放 s 和 t 的字符映射</li>
<li>遍历，如果遍历到相同的字符hm.get()不同则return false</li>
<li>需要对s和t都要遍历</li>
<li>如&quot;ab&quot;,&ldquo;aa&quot;的test case第一次遍历得到[&lsquo;a&rsquo;,&lsquo;a&rsquo;],[&lsquo;b&rsquo;,&lsquo;a&rsquo;], 第二次[&lsquo;a&rsquo;,&lsquo;a&rsquo;],[&lsquo;a&rsquo;,&lsquo;b&rsquo;] return false</li>
<li>Runtime: 64%</li>
</ul>
</li>
<li>Solution2，HashMap使用Obejct[]数组重写
<ul>
<li>字符ASCII码的存放index，值对应HashMap的key，val</li>
<li>Runtime: 76%</li>
</ul>
</li>
</ol>
<h2 id="206-reverse-linked-list">[206] Reverse Linked List</h2>
<ul>
<li><a href="https://leetcode.com/problems/reverse-linked-list/">https://leetcode.com/problems/reverse-linked-list/</a></li>
</ul>
<h2 id="217-存在重复元素">[217] 存在重复元素##</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/contains-duplicate/description/">https://leetcode-cn.com/problems/contains-duplicate/description/</a></li>
</ul>
<ol>
<li>Solution1, 简单HashMap/ HashSet, Time: 48%/ 55%</li>
<li>Solution2, HashSet比较长度, Time: 70%
<ul>
<li>HashSet特点：无序；不存储重复元素；没有get()，只能iterator访问</li>
<li>遍历一遍存入HashSet，<code>HashSet.size() &lt; nums.length() ? true : false </code></li>
</ul>
</li>
<li>内置流，比较<code>return Arrays.stream(nums).distinct().count() &lt; nums.length</code>，Time: 55%</li>
<li>排序后比较<code>nums[i] == nums[i - 1]</code>, Time: 99%</li>
</ol>
<h2 id="219-存在重复元素-ii">[219] 存在重复元素 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/description/">https://leetcode-cn.com/problems/contains-duplicate-ii/description/</a></li>
<li>HashMap存Index，每次比较，达条件return true，否则更新Index</li>
</ul>
<h2 id="225-用队列实现栈">[225] 用队列实现栈</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/description/">https://leetcode-cn.com/problems/implement-stack-using-queues/description/</a></li>
<li>双队列实现，a：临时队列，b：总队列</li>
<li>队列a存当前push的数，队列b存之前处理完的完整栈</li>
<li>当前push的存到a的头，把b的每一个add到a的尾</li>
<li>核心：每次完成add后交换a和b，保证a始终为空</li>
</ul>
<h2 id="226-翻转二叉树">[226] 翻转二叉树</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/invert-binary-tree/description/">https://leetcode-cn.com/problems/invert-binary-tree/description/</a></li>
<li>递归调换，先进入子树调换完，再调换root.left, root.right</li>
</ul>
<h2 id="231-2的幂">[231] 2的幂</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/power-of-two/description/">https://leetcode-cn.com/problems/power-of-two/description/</a></li>
<li>2的倍数二进制第一位为1，后面均为0，取最高位异或本身</li>
<li>处理 <code>n &lt;= 0</code>的情况</li>
<li><code>return (Integer.highestOneBit(n) ^ n) == 0</code> Runtime: 23%</li>
<li><code>return (Integer.highestOneBit(n) ^ n) == 0 ? true : false</code> Runtime: 100%</li>
</ul>
<h2 id="232-用栈实现队列">[232] 用栈实现队列</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/description/">https://leetcode-cn.com/problems/implement-queue-using-stacks/description/</a></li>
<li>双栈<code>in</code>和<code>out</code></li>
<li>Push: <code>in.push()</code></li>
<li>Pop: 若<code>out</code>不为空则<code>out.pop()</code>，若<code>out</code>空则<code>out.push(in.pop())</code>转移所有<code>in</code>元素，再<code>out.pop()</code></li>
</ul>
<h2 id="234-回文链表">[234] 回文链表</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/palindrome-linked-list/description/">https://leetcode-cn.com/problems/palindrome-linked-list/description/</a></li>
<li>Time: O(n), Space: O(1)</li>
<li>
<ol>
<li>快指针指到头时慢指针指到中间</li>
<li>反向慢指针到结尾之间的节点</li>
<li>逐个比较前一半和反向过的后一半</li>
</ol>
</li>
</ul>
<h2 id="235-二叉搜索树的最近公共祖先">[235] 二叉搜索树的最近公共祖先</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/</a></li>
<li>利用二叉搜索树特性：left.val &lt; root.val &lt; right.val</li>
<li>若p、q &lt; root 则一定在左子树中，若p、q &gt; root 则一定在右子树中，否则return root</li>
</ul>
<h2 id="237-删除链表中的节点">[237] 删除链表中的节点</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/description/">https://leetcode-cn.com/problems/delete-node-in-a-linked-list/description/</a></li>
<li>next.val赋值给node,删除下一个node</li>
</ul>
<h2 id="242-有效的字母异位词">[242] 有效的字母异位词</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-anagram/description/">https://leetcode-cn.com/problems/valid-anagram/description/</a></li>
<li>三种解法：HashMap, Alphabet Array, Arrays.toCharArray() -&gt; Sort()</li>
</ul>
<h2 id="257-二叉树的所有路径">[257] 二叉树的所有路径</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-paths/description/">https://leetcode-cn.com/problems/binary-tree-paths/description/</a></li>
<li>traverse()函数，递归深入</li>
</ul>
<h2 id="258-各位相加">[258] 各位相加</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/add-digits/description/">https://leetcode-cn.com/problems/add-digits/description/</a></li>
<li>找规律</li>
</ul>
<h2 id="263-丑数">[263] 丑数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/ugly-number/description/">https://leetcode-cn.com/problems/ugly-number/description/</a></li>
<li>除到底，判断是否有因子</li>
</ul>
<h2 id="268-缺失数字">[268] 缺失数字</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/missing-number/description/">https://leetcode-cn.com/problems/missing-number/description/</a></li>
<li>1 - n 相加减去nums中的和</li>
</ul>
<h2 id="278-第一个错误的版本">[278] 第一个错误的版本</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/first-bad-version/description/">https://leetcode-cn.com/problems/first-bad-version/description/</a></li>
<li>简单二分，注意循环条件</li>
</ul>
<h2 id="283--move-zeros0元素移到最后其他不变">[283]  Move Zeros，0元素移到最后，其他不变</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/move-zeroes">https://leetcode-cn.com/problems/move-zeroes</a></li>
</ul>
<ol>
<li>S1，快慢双指针遍历</li>
<li>S2，单指针，非0往前移，统计0个数n；后n个置0</li>
</ol>
<h2 id="290-单词规律">[290] 单词规律</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/word-pattern/description/">https://leetcode-cn.com/problems/word-pattern/description/</a></li>
</ul>
<ol>
<li>Solution
<ul>
<li>简单HashMap，注意区分a和b的value不能相等，通过加入时判断<code>hm.containsValue</code></li>
<li>使用<code>Object.equals()</code>取代 <code>==</code> 更健壮</li>
</ul>
</li>
</ol>
<h2 id="344-反转字符串">[344] 反转字符串##</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/reverse-string/description/">https://leetcode-cn.com/problems/reverse-string/description/</a></li>
<li>循环到中间</li>
</ul>
<h2 id="350-两个数组的交集-ii">[350] 两个数组的交集 II</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/description/">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/description/</a></li>
<li>HashMap两次遍历两个数组</li>
</ul>
<h2 id="367-有效的完全平方数">[367] 有效的完全平方数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-perfect-square/description/">https://leetcode-cn.com/problems/valid-perfect-square/description/</a></li>
<li>从<code>left = 0, right = num</code>开始二分</li>
</ul>
<pre><code class="language-java">long mid = left + (right - left) / 2
long t = mid * mid
if(t == num) return true;
else if(t &lt; num) left = mid + 1;
else right = mid - 1; 
</code></pre>
<ul>
<li>注意要用<code>long</code>数据类型</li>
</ul>
<h2 id="383-赎金信">[383] 赎金信</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/ransom-note/description/">https://leetcode-cn.com/problems/ransom-note/description/</a></li>
<li><code>int[26]</code>数组遍历<code>magzine</code>统计26个字母使用次数，再遍历<code>ransomNote</code>, <code>if 对应字母 &lt;= 0</code>则return</li>
</ul>
<h2 id="387-字符串中的第一个唯一字符">[387] 字符串中的第一个唯一字符</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/description/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/description/</a></li>
</ul>
<ol>
<li>Solution1， HashMap计次数，遍历两次String
<ul>
<li>Runtime: 30%</li>
<li>Time: O(n) //2n</li>
</ul>
</li>
<li>字母表数组计数，原理&amp;Time同HashMap
<ul>
<li>Runtime: 86%</li>
</ul>
</li>
</ol>
<h2 id="476-数字的补数">[476] 数字的补数</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-complement/description/">https://leetcode-cn.com/problems/number-complement/description/</a></li>
<li>直接 ~ 按位取反，前缀的0也会被取反。</li>
<li>所以用 ^ 异或，直接<code>^1</code>前面的位数也会异或，用与<code>num</code>相同位数的数异或</li>
<li>如：101 ^ 111 = 010。怎么得到111？考虑111 + 1 = 1000，而1000又是 最小的 大于101的 只有一位是1 的二进制数。</li>
<li>解决方法：
<ol>
<li>找到最小的大于原数字的二进制值仅有一位为1的数；</li>
<li>将此数减1；</li>
<li>与原数字按位求异或。</li>
</ol>
</li>
<li><code>Integer.highestOneBit(num)</code>：拿到num最高位，后面补0，如 101 返回 100</li>
</ul>
<h2 id="496-下一个更大元素-i">[496] 下一个更大元素 I</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-i/description/">https://leetcode-cn.com/problems/next-greater-element-i/description/</a></li>
<li>HashMap 简单解法</li>
</ul>
<h2 id="543-二叉树的直径">[543] 二叉树的直径</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/description/">https://leetcode-cn.com/problems/diameter-of-binary-tree/description/</a></li>
<li><strong>depth = Math.max( depth, left_depth + right_depth )</strong></li>
<li><strong>向上一层 return 1 + Math.max( left_depth, right_depth )</strong></li>
</ul>
<h2 id="771-宝石与石头">[771] 宝石与石头</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/jewels-and-stones/description/">https://leetcode-cn.com/problems/jewels-and-stones/description/</a></li>
<li>简单<code>HashMap</code></li>
</ul>
<h2 id="844-比较含退格的字符串">[844] 比较含退格的字符串</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/backspace-string-compare/description/">https://leetcode-cn.com/problems/backspace-string-compare/description/</a></li>
<li>栈比字符串性能高挺多</li>
</ul>
<h2 id="860-柠檬水找零">[860] 柠檬水找零##</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/lemonade-change/description/">https://leetcode-cn.com/problems/lemonade-change/description/</a></li>
<li>维护两个变量，统计5和10的个数</li>
<li>对每个bill需要找零的情况分情况讨论
<ul>
<li>5: 不找</li>
<li>10: 找5，收10</li>
<li>20: 找三张5，或一张5一张10</li>
</ul>
</li>
</ul>
<h2 id="876-链表的中间结点">[876] 链表的中间结点</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/description/">https://leetcode-cn.com/problems/middle-of-the-linked-list/description/</a></li>
<li>快慢指针，注意 if( p.next! = null )</li>
</ul>
<h2 id="993-二叉树的堂兄弟节点">[993] 二叉树的堂兄弟节点</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/description/">https://leetcode-cn.com/problems/cousins-in-binary-tree/description/</a></li>
<li>递归遍历，到x, y节点保存parent和depth</li>
<li>最后比较 parent不相等且depth相等</li>
</ul>
<h2 id="997-找到小镇的法官">[997] 找到小镇的法官</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/find-the-town-judge/description/">https://leetcode-cn.com/problems/find-the-town-judge/description/</a></li>
<li>有向图，[a, b]表示从顶点a出发指向顶点b的一条有向边。</li>
<li>是否存在且只存在一个顶点，所有的顶点都指向他，但是这个点不指向任何点。</li>
<li>即该顶点的入度是N - 1，出度是0。</li>
<li>使用一个数组存储每个点的入度和出度的差，当某个点的入度和出度的差是N - 1时，代表他是法官，否则不存在。</li>
<li>证明：如果入度和出度的差 = N - 1，又入度、出度 &gt;= 0，那么入度 = N- 1，出度 = 0，满足条件1和2。一旦存在一个点满足条件，那么说明这个点没有出度，所以不存在另一个点的入度是N - 1，满足条件3。</li>
</ul>
<h2 id="1046-最后一块石头的重量">[1046] 最后一块石头的重量</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/last-stone-weight/">https://leetcode-cn.com/problems/last-stone-weight/</a></li>
</ul>
<h2 id="1232-缀点成线">[1232] 缀点成线</h2>
<ul>
<li><a href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/description/">https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/description/</a></li>
<li>只存在两个点直接return true</li>
<li>检查第三个点与12两点之间的斜率是否相等(乘法计算替代除法，防止除数corner case)</li>
</ul>
                    </div>
                    
                    

                    

                    
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">下一页</span>
        <a href="/zh/docs/notes/medium/" class="block">Medium</a>
        
    </div>
</div>

                    

<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zjoey" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


                </div>
                
                <div class="hidden lg:block lg:w-1/4">
                    
                    <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-secondary-bg pt-16 -mt-16 ">
    <span class="text-lg font-semibold">本页内容</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6  pt-10 -mt-10 border-l ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-two-sum-两数之和">[1] Two Sum 两数之和</a></li>
    <li><a href="#7-reverse-int">[7] Reverse Int</a></li>
    <li><a href="#9-ispalindrome">[9] isPalindrome</a></li>
    <li><a href="#14-longestcommonprefix">[14] longestCommonPrefix</a></li>
    <li><a href="#20-valid-parentheses判断对等括号">[20] Valid Parentheses，判断对等括号</a></li>
    <li><a href="#26-remove-duplicated-from-sorted-array-删除排序数组中的重复项">[26] Remove Duplicated from Sorted Array 删除排序数组中的重复项</a></li>
    <li><a href="#27-remove-element-移除元素">[27] Remove Element 移除元素</a></li>
    <li><a href="#28-实现-strstr">[28] 实现 strStr()</a></li>
    <li><a href="#35-search-insert-position-搜索插入位置">[35] Search Insert Position 搜索插入位置</a></li>
    <li><a href="#38-count-and-say-外观数列">[38] Count and Say 外观数列</a></li>
    <li><a href="#53-maximum-subarray">[53] Maximum Subarray</a></li>
    <li><a href="#58-最后一个单词的长度">[58] 最后一个单词的长度</a></li>
    <li><a href="#66-plus-one">[66] Plus One</a></li>
    <li><a href="#67-二进制求和">[67] 二进制求和</a></li>
    <li><a href="#70-爬楼梯">[70] 爬楼梯</a></li>
    <li><a href="#83-删除排序链表中的重复元素">[83] 删除排序链表中的重复元素</a></li>
    <li><a href="#88-merge-sorted-array">[88] Merge Sorted Array</a></li>
    <li><a href="#100-相同的树">[100] 相同的树</a></li>
    <li><a href="#101-对称二叉树">[101] 对称二叉树</a></li>
    <li><a href="#104-二叉树的最大深度">[104] 二叉树的最大深度</a></li>
    <li><a href="#107-二叉树的层次遍历-ii">[107] 二叉树的层次遍历 II</a></li>
    <li><a href="#108-将有序数组转换为二叉搜索树">[108] 将有序数组转换为二叉搜索树</a></li>
    <li><a href="#110-平衡二叉树">[110] 平衡二叉树</a></li>
    <li><a href="#111-二叉树的最小深度">[111] 二叉树的最小深度</a></li>
    <li><a href="#112-路径总和">[112] 路径总和</a></li>
    <li><a href="#118-杨辉三角">[118] 杨辉三角</a></li>
    <li><a href="#119-杨辉三角2">[119] 杨辉三角2</a></li>
    <li><a href="#121-best-time-to-buy-and-sell-stock买卖股票的最佳时机">[121] best-time-to-buy-and-sell-stock，买卖股票的最佳时机</a></li>
    <li><a href="#122-best-time-to-buy-and-sell-stock-ii买卖股票的最佳时机-ii">[122] best-time-to-buy-and-sell-stock-ii，买卖股票的最佳时机 II</a></li>
    <li><a href="#125-验证回文串">[125] 验证回文串</a></li>
    <li><a href="#136-singlenumber">[136] SingleNumber</a></li>
    <li><a href="#141-环形链表">[141] 环形链表</a></li>
    <li><a href="#155-最小栈">[155] 最小栈</a></li>
    <li><a href="#160-相交链表">[160] 相交链表</a></li>
    <li><a href="#167-两数之和-ii---输入有序数组">[167] 两数之和 II - 输入有序数组</a></li>
    <li><a href="#168-excel表列名称">[168] Excel表列名称</a></li>
    <li><a href="#169-多数元素">[169] 多数元素</a></li>
    <li><a href="#171-excel表列序号">[171] Excel表列序号</a></li>
    <li><a href="#172-阶乘后的零">[172] 阶乘后的零</a></li>
    <li><a href="#189-旋转数组">[189] 旋转数组</a></li>
    <li><a href="#190-颠倒二进制位">[190] 颠倒二进制位</a></li>
    <li><a href="#191-位1的个数">[191] 位1的个数</a></li>
    <li><a href="#198-打家劫舍">[198] 打家劫舍</a></li>
    <li><a href="#202-happy-number">[202] Happy Number</a></li>
    <li><a href="#203-移除链表元素">[203] 移除链表元素</a></li>
    <li><a href="#204-计数质数">[204] 计数质数</a></li>
    <li><a href="#205-同构字符串">[205] 同构字符串</a></li>
    <li><a href="#206-reverse-linked-list">[206] Reverse Linked List</a></li>
    <li><a href="#217-存在重复元素">[217] 存在重复元素##</a></li>
    <li><a href="#219-存在重复元素-ii">[219] 存在重复元素 II</a></li>
    <li><a href="#225-用队列实现栈">[225] 用队列实现栈</a></li>
    <li><a href="#226-翻转二叉树">[226] 翻转二叉树</a></li>
    <li><a href="#231-2的幂">[231] 2的幂</a></li>
    <li><a href="#232-用栈实现队列">[232] 用栈实现队列</a></li>
    <li><a href="#234-回文链表">[234] 回文链表</a></li>
    <li><a href="#235-二叉搜索树的最近公共祖先">[235] 二叉搜索树的最近公共祖先</a></li>
    <li><a href="#237-删除链表中的节点">[237] 删除链表中的节点</a></li>
    <li><a href="#242-有效的字母异位词">[242] 有效的字母异位词</a></li>
    <li><a href="#257-二叉树的所有路径">[257] 二叉树的所有路径</a></li>
    <li><a href="#258-各位相加">[258] 各位相加</a></li>
    <li><a href="#263-丑数">[263] 丑数</a></li>
    <li><a href="#268-缺失数字">[268] 缺失数字</a></li>
    <li><a href="#278-第一个错误的版本">[278] 第一个错误的版本</a></li>
    <li><a href="#283--move-zeros0元素移到最后其他不变">[283]  Move Zeros，0元素移到最后，其他不变</a></li>
    <li><a href="#290-单词规律">[290] 单词规律</a></li>
    <li><a href="#344-反转字符串">[344] 反转字符串##</a></li>
    <li><a href="#350-两个数组的交集-ii">[350] 两个数组的交集 II</a></li>
    <li><a href="#367-有效的完全平方数">[367] 有效的完全平方数</a></li>
    <li><a href="#383-赎金信">[383] 赎金信</a></li>
    <li><a href="#387-字符串中的第一个唯一字符">[387] 字符串中的第一个唯一字符</a></li>
    <li><a href="#476-数字的补数">[476] 数字的补数</a></li>
    <li><a href="#496-下一个更大元素-i">[496] 下一个更大元素 I</a></li>
    <li><a href="#543-二叉树的直径">[543] 二叉树的直径</a></li>
    <li><a href="#771-宝石与石头">[771] 宝石与石头</a></li>
    <li><a href="#844-比较含退格的字符串">[844] 比较含退格的字符串</a></li>
    <li><a href="#860-柠檬水找零">[860] 柠檬水找零##</a></li>
    <li><a href="#876-链表的中间结点">[876] 链表的中间结点</a></li>
    <li><a href="#993-二叉树的堂兄弟节点">[993] 二叉树的堂兄弟节点</a></li>
    <li><a href="#997-找到小镇的法官">[997] 找到小镇的法官</a></li>
    <li><a href="#1046-最后一块石头的重量">[1046] 最后一块石头的重量</a></li>
    <li><a href="#1232-缀点成线">[1232] 缀点成线</a></li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
                    
                </div>
                
            </div>

        </div>


    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        hljs.initHighlightingOnLoad();
        changeSidebarHeight();
        switchDocToc();
    })
</script>









            </div>
        </div>
        
    </main>
    <footer class="pl-scrollbar">
        <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2020 <a href="https://www.zjoey.com/">z. Joey &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
    </footer>
</body>

</html>